<!DOCTYPE html>

<html lang="es">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Americanas Gaby</title>
<!-- ‚úÖ Tailwind CSS desde CDN (requisito) -->
<script src="https://cdn.tailwindcss.com"></script>
<style>
    .tab-active { background: #0f172a; color: white; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  
    .btn-primary{padding:.5rem 1rem;border-radius:.75rem;background:#2563eb;color:#fff;box-shadow:0 1px 2px rgba(0,0,0,.08);}
    .btn-primary:hover{background:#1d4ed8;}
    .btn-secondary{padding:.5rem 1rem;border-radius:.75rem;background:#fff;border:1px solid #e2e8f0;box-shadow:0 1px 2px rgba(0,0,0,.04);}
    .btn-secondary:hover{background:#f8fafc;}
    
    .btn-success{padding:.5rem 1rem;border-radius:.75rem;background:#16a34a;color:#fff;box-shadow:0 1px 2px rgba(0,0,0,.08);}
    .btn-success:hover{background:#15803d;}
.btn-danger{padding:.5rem 1rem;border-radius:.75rem;background:#e11d48;color:#fff;box-shadow:0 1px 2px rgba(0,0,0,.08);}
    .btn-danger:hover{background:#be123c;}
    .btn-success{padding:.5rem 1rem;border-radius:.75rem;background:#059669;color:#fff;box-shadow:0 1px 2px rgba(0,0,0,.08);}
    .btn-success:hover{background:#047857;}
    .card{border:1px solid #e2e8f0;border-radius:1rem;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:1rem;}
    .card-muted{border:1px solid #e2e8f0;border-radius:1rem;background:#f8fafc;padding:1rem;}
    .sticky-bar{position:sticky;top:0;z-index:30;background:rgba(248,250,252,.95);backdrop-filter:blur(6px);border-bottom:1px solid #e2e8f0;}

</style>
<link href="manifest.json" rel="manifest"/><meta content="#38bdf8" name="theme-color"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="Americanas Gaby" name="apple-mobile-web-app-title"/><link href="assets/icons/apple-touch-icon.png" rel="apple-touch-icon"/></head>
<body class="bg-slate-50 text-slate-900">
<div class="max-w-6xl mx-auto p-4 sm:p-6">
<header class="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
<div>
<h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight flex items-center gap-2"><img src="assets/icons/icon-192.png" alt="Americanas Gaby" class="w-7 h-7 rounded-md"/><span id="appTitleText">Americanas Gaby</span></h1>
<p class="text-slate-600" id="appSubtitleText">Pistas simult√°neas ¬∑ parejas IZQ‚ÄìDER ¬∑ sin repetir parejas ¬∑ ranking final</p>
</div>
<div class="flex gap-2"><button class="px-3 py-2 rounded-xl bg-sky-500 text-white shadow-sm hover:bg-sky-600 text-sm hidden" id="btnInstall">Instalar</button>
<button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-50 text-sm" id="btnImport">Importar (JSON)</button><button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-50 text-sm" id="btnExport">
          Exportar (JSON)
        </button>
<button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-50 text-sm" id="btnExportCSV">
          Exportar (Excel/CSV)
        </button>
<button class="btn-danger" id="btnReset">
          Reset (borrar todo)
        </button>
<input accept="application/json,.json" class="hidden" id="fileImport" type="file"/></div>
</header>
<nav class="mt-6 bg-white border rounded-2xl shadow-sm p-2">
<div class="flex flex-wrap gap-2">
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="setup">1) Jugadoras</button>
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="plan">2) Jornada</button>
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="match">3) Partido</button>
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="ranking">4) Ranking</button>
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="stats">5) Estad√≠sticas</button>
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="history">6) Historial</button>
<button class="tab px-3 py-2 rounded-xl text-sm font-medium hover:bg-slate-100" data-tab="veteranas">7) Veteranas</button>
</div>
</nav>
<!-- TAB 1: Jugadoras -->
<section class="tab-panel mt-6" id="tab-setup">
<div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
<div class="bg-white border rounded-2xl shadow-sm p-4">
<h2 class="text-lg font-semibold">A√±adir jugadora</h2>
<p class="text-sm text-slate-600 mt-1">
            Indica nombre y rol: <b>Izquierda</b>, <b>Derecha</b> o <b>Comod√≠n</b>.
          </p>
<div class="mt-4 space-y-3">
<div>
<label class="block text-sm font-medium">Nombre</label>
<input class="w-full rounded-xl border px-3 py-3" id="playerName" placeholder="Ej: Laura"/>
</div>
<div>
<label class="block text-sm font-medium">Rol</label>
<select class="w-full rounded-xl border px-3 py-3" id="playerRole">
<option value="L">IZQUIERDA</option>
<option value="R">DERECHA</option>
<option value="C">COMOD√çN</option>
</select>
</div>
<button class="w-full px-4 py-2 rounded-xl bg-emerald-600 text-white hover:bg-emerald-700 shadow-sm" id="btnAddPlayer">
              A√±adir
            </button>
<details class="rounded-xl border bg-slate-50 p-3">
<summary class="cursor-pointer text-sm font-semibold">Importaci√≥n r√°pida (opcional)</summary>
<p class="text-sm text-slate-600 mt-2">
                Una jugadora por l√≠nea: <span class="mono">Nombre,Rol</span> (Rol: L/R/C)
              </p>
<textarea class="w-full mt-2 rounded-xl border px-3 py-3 mono text-sm" id="bulkImport" placeholder="Ana,L
Bea,R
Cris,C" rows="4"></textarea>
<div class="flex gap-2 mt-2">
<button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-100 text-sm" id="btnBulkImport">
                  Importar
                </button>
<button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-100 text-sm" id="btnBulkClear">
                  Limpiar
                </button>
</div>
</details>
</div>
</div>
<div class="bg-white border rounded-2xl shadow-sm p-4 lg:col-span-2">
<div class="flex items-center justify-between gap-2">
<h2 class="text-lg font-semibold">Listado de jugadoras</h2>
<div class="text-sm text-slate-600" id="playersCount">0 jugadoras</div>
</div>
<div class="mt-3 overflow-auto border rounded-2xl">
<table class="min-w-full text-sm">
<thead class="bg-slate-100 text-slate-700">
<tr>
<th class="text-left p-3">Nombre</th>
<th class="text-left p-3">Rol</th>
<th class="text-left p-3">Puntos acumulados</th>
<th class="text-right p-3">Acciones</th>
</tr>
</thead>
<tbody id="playersTable"></tbody>
</table>
</div>
<div class="mt-4 rounded-xl border bg-slate-50 p-3 text-sm text-slate-700">
<div class="font-semibold">Reglas de emparejamiento</div>
<ul class="list-disc pl-5 mt-1 space-y-1">
<li>Las parejas se forman siempre <b>IZQUIERDA - DERECHA</b>.</li>
<li>Una jugadora <b>COMOD√çN</b> puede ocupar izquierda o derecha.</li>
<li>Una jugadora solo puede aparecer <b>una vez</b> por ronda (no puede jugar en dos pistas a la vez).</li>
<li>En la jornada, el sistema intenta que <b>no se repitan parejas</b> (hist√≥rico global).</li>
</ul>
</div>
</div>
</div>
</section>
<!-- TAB 2: Jornada -->
<section class="tab-panel mt-6 hidden" id="tab-plan">
<div class="bg-white border rounded-2xl shadow-sm p-4">
<h2 class="text-lg font-semibold">Planificar jornada (90 minutos)</h2>
<p class="text-sm text-slate-600 mt-1">
          Indica <b>pistas disponibles</b>. En cada pista juegan 2 parejas (4 jugadoras).
          Si hay 1 pista ‚Üí 1 partido por ronda; 2 pistas ‚Üí 2 partidos por ronda; etc.
        </p>
<div class="mt-4 grid grid-cols-1 md:grid-cols-4 gap-3">
<div>
<label class="block text-sm font-medium">Pistas disponibles</label>
<input class="w-full rounded-xl border px-3 py-3" id="courtCount" min="1" placeholder="Ej: 2" step="1" type="number"/>
<p class="text-xs text-slate-500 mt-1">Cada pista usa 4 jugadoras por ronda.</p>
</div>
<div>
<label class="block text-sm font-medium">Jugadoras a incluir</label>
<input class="w-full rounded-xl border px-3 py-3" id="includeCount" min="4" placeholder="Ej: 8" step="1" type="number" inputmode="numeric" pattern="[0-9]*">
<p class="text-xs text-slate-500 mt-1" id="needPlayersHint">M√≠nimo: --</p>
</div>
<div>
<label class="block text-sm font-medium">Rondas (n¬∫ de turnos)</label>
<input class="w-full rounded-xl border px-3 py-3" id="matchCount" min="1" placeholder="Ej: 6" step="1" type="number" inputmode="numeric" pattern="[0-9]*">
<p class="text-xs text-slate-500 mt-1">Cada ronda genera <b>pistas</b> partidos simult√°neos.</p>

<p class="text-xs text-slate-500 mt-2">
  <span class="font-semibold">Sugerencia:</span>
  <span id="suggestedRoundsLabel">--</span>
  <button type="button" id="btnApplySuggestedRounds" class="ml-2 underline text-slate-700 hover:text-slate-900">Aplicar</button>
</p>
<p class="text-xs text-slate-500 mt-1" id="suggestedRoundsExplain">--</p>

</div>
<div>
<label class="block text-sm font-medium">Duraci√≥n total de la jornada (min)</label>
<input class="w-full rounded-xl border px-3 py-3" id="totalDurationMin" min="10" step="5" type="number" value="90" inputmode="numeric" pattern="[0-9]*">
<p class="text-xs text-slate-500 mt-1">Se reparte entre las rondas.</p>
</div>
<div class="rounded-2xl border bg-slate-50 p-3">

<div class="text-sm text-slate-600">Duraci√≥n por ronda</div>
<div class="text-2xl font-bold mono" id="matchDurationLabel">--:--</div>
<div class="text-xs text-slate-500"><span id="totalDurationHint">90</span> min / n¬∫ de rondas</div>
</div>
<div class="md:col-span-4">
<label class="block text-sm font-medium">Selecciona jugadoras para esta jornada</label>
<div class="mt-2 flex flex-wrap gap-2">
<button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-50 text-sm" id="btnSelectAllPlayers" type="button">
                Seleccionar todas
              </button>
<button class="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-slate-50 text-sm" id="btnClearSelectedPlayers" type="button">
                Quitar selecci√≥n
              </button>
</div>
<div class="mt-2 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2" id="includePlayersGrid"></div>
<p class="text-xs text-slate-500 mt-2">Si marcas menos de las necesarias, se completa aleatoriamente.</p>
</div>
</div>
<div class="mt-4 hidden rounded-xl border p-3 text-sm" id="planMsg"></div>
<div class="mt-4 flex flex-col sm:flex-row gap-2">
<button class="px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700 shadow-sm" id="btnBuildSchedule">
            Generar jornada (sin repetir parejas)
          </button>
<button class="px-4 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm" id="btnClearSchedule">
            Limpiar jornada
          </button>
</div>
<div class="mt-5">
<h3 class="font-semibold">Rondas planificadas</h3>
<div class="mt-2 space-y-3" id="scheduleList"></div>
</div>
</div>
</section>
<!-- TAB 3: Partido -->
<section class="tab-panel mt-6 hidden" id="tab-match">
<div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
<div class="bg-white border rounded-2xl shadow-sm p-4 lg:col-span-2">
<div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
<div>
<h2 class="text-lg font-semibold">Ronda en curso</h2>
<p class="text-sm text-slate-600 mt-1">Esta ronda puede tener varias pistas (partidos simult√°neos).</p>
</div>
<div class="card-muted sticky-bar px-4 py-4 mt-2">
<div class="text-xs text-slate-600">Temporizador</div>
<div class="text-3xl font-bold mono" id="timerLabel">00:00</div>
<div class="flex gap-2 mt-2">
<button class="btn-success text-sm" id="btnStart">Iniciar</button>
<button class="btn-secondary text-sm" id="btnPause">Pausar</button>
<button class="btn-secondary text-sm" id="btnResetTimer">Reiniciar</button>
<button class="btn-danger text-sm" id="btnFinishRound">Finalizar ronda</button>
</div>
</div>
</div>
<div class="mt-4 hidden rounded-xl border p-3 text-sm" id="matchMsg"></div>
<div class="mt-4 rounded-2xl border bg-white p-4">
<div class="flex items-center justify-between">
<h3 class="font-semibold">Pistas y parejas</h3>
<div class="text-sm text-slate-600" id="currentMatchIndexLabel">Ronda -/-</div>
</div>
<div class="mt-3 grid grid-cols-1 gap-3" id="currentMatchPairs"></div>
</div>
<div class="mt-4 rounded-2xl border bg-white p-4">
<h3 class="font-semibold">Resultados</h3>
<div class="mt-3 flex flex-wrap items-center gap-3">
  <div class="text-sm font-medium text-slate-700">Tipo de marcador:</div>
  <label class="flex items-center gap-2 text-sm">
    <input type="radio" name="scoreMode" value="games" id="scoreModeGames" checked>
    Juegos
  </label>
  <label class="flex items-center gap-2 text-sm">
    <input type="radio" name="scoreMode" value="points" id="scoreModePoints">
    Puntos
  </label>
  <label class="flex items-center gap-2 text-sm">
    <input type="radio" name="scoreMode" value="both" id="scoreModeBoth">
    Juegos + Puntos
  </label>
  <div class="text-xs text-slate-500">El ranking prioriza: <b>Partidos</b> ‚Üí <b>Juegos</b> ‚Üí <b>Puntos</b>.</div>
</div>

<div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
<div>
<label class="block text-sm font-medium">Fecha</label>
<input class="w-full rounded-xl border px-3 py-3" id="resultDate" type="date"/>
</div>
<div>
<label class="block text-sm font-medium">Comentario (opcional)</label>
<input class="w-full rounded-xl border px-3 py-3" id="resultComment"/>
</div>
</div>
<div class="mt-4" id="resultsGrid"></div>
<div class="mt-4 flex flex-col sm:flex-row gap-2">
<button class="btn-primary" disabled="" id="btnSaveResult">
                Guardar resultado de la ronda
              </button>
<button class="btn-secondary" disabled="" id="btnNextMatch">
                Siguiente ronda (mostrar + iniciar)
              </button>
</div>
</div>
</div>
<div class="bg-white border rounded-2xl shadow-sm p-4">
<h2 class="text-lg font-semibold">Control r√°pido</h2>
<div class="mt-4 space-y-3 text-sm">
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Rondas planificadas</div>
<div class="text-xl font-bold" id="statPlanned">0</div>
</div>
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Rondas completadas</div>
<div class="text-xl font-bold" id="statDone">0</div>
</div>
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Duraci√≥n por ronda</div>
<div class="text-xl font-bold mono" id="statDuration">--:--</div>
</div>
<button class="w-full px-4 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm" id="btnGoRanking">Ver ranking</button>
</div>
</div>
</div>
</section>
<!-- TAB 4: Ranking -->
<section class="tab-panel mt-6 hidden" id="tab-ranking">
<div class="bg-white border rounded-2xl shadow-sm p-4">
<div class="flex items-center justify-between gap-2">
<div>
<h2 class="text-lg font-semibold">Ranking</h2>
<p class="text-sm text-slate-600 mt-1">Ordenado por puntos acumulados.</p>
</div>
<button class="px-4 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm" id="btnRecalcRanking">Refrescar</button>
</div>
<p class="text-xs text-slate-500 mt-2" id="rankingNote"></p>
<div class="mt-4 overflow-auto border rounded-2xl">
<table class="min-w-full text-sm">
<thead class="bg-slate-100 text-slate-700">
<tr>
<th class="text-left p-3">#</th>
<th class="text-left p-3">Jugadora</th>
<th class="text-left p-3">Rol</th>
<th class="text-left p-3">Partidos (G-P)</th>
<th class="text-left p-3">Juegos (GF-GC)</th>
<th class="text-left p-3">Puntos (PF-PC)</th>
<th class="text-left p-3">PJG</th>
</tr>
</thead>
<tbody id="rankingTable"></tbody>
</table>
</div>
</div>
</section>
<!-- TAB 5: Estad√≠sticas -->
<section class="tab-panel mt-6 hidden" id="tab-stats">
  <div class="card">
    <div class="flex items-start justify-between gap-3">
      <div>
        <h2 class="text-xl font-bold">Estad√≠sticas</h2>
        <p class="text-sm text-slate-600 mt-1">Se calculan con los resultados guardados en cada ronda.</p>
      </div>
      <div class="text-right text-xs text-slate-500">
        <div><span class="font-semibold">Modo ranking:</span> Partidos ‚Üí Juegos ‚Üí Puntos</div>
      </div>
    </div>

    <div class="mt-4 flex flex-wrap gap-2">
      <button class="btn-secondary px-3 py-2 rounded-xl text-sm font-medium stats-tab tab-active" data-stats="americanas">Americanas</button>
      <button class="btn-secondary px-3 py-2 rounded-xl text-sm font-medium stats-tab" data-stats="veteranas">Veteranas</button>
    </div>

    <div id="stats-americanas" class="mt-4">
    <div class="mt-4 overflow-auto border rounded-2xl">
      <table class="min-w-full text-sm">
        <thead class="bg-slate-100 text-slate-700">
          <tr>
            <th class="text-left p-3">#</th>
            <th class="text-left p-3">Jugadora</th>
            <th class="text-left p-3">Rol</th>
            <th class="text-left p-3">PJG</th>
            <th class="text-left p-3">G</th>
            <th class="text-left p-3">P</th>
            <th class="text-left p-3">Juegos (GF-GC)</th>
            <th class="text-left p-3">Puntos (PF-PC)</th>
            <th class="text-left p-3">%G</th>
          </tr>
        </thead>
        <tbody id="statsTable"></tbody>
      </table>
    </div>

    <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
      <div class="card-muted">
        <div class="font-semibold">Top parejas</div>
        <div class="text-xs text-slate-600 mt-1">Por victorias (desempate por diferencial de juegos y puntos).</div>
        <div class="mt-3 text-sm" id="topPairsList">--</div>
      </div>
      <div class="card-muted">
        <div class="font-semibold">Resumen</div>
        <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
          <div><div class="text-xs text-slate-600">Rondas jugadas</div><div class="text-lg font-bold" id="statRoundsPlayed2">--</div></div>
          <div><div class="text-xs text-slate-600">Partidos totales</div><div class="text-lg font-bold" id="statMatchesTotal">--</div></div>
          <div><div class="text-xs text-slate-600">Juegos totales</div><div class="text-lg font-bold" id="statGamesTotal">--</div></div>
          <div><div class="text-xs text-slate-600">Puntos totales</div><div class="text-lg font-bold" id="statPointsTotal">--</div></div>
        </div>
      </div>
    </div>
    </div>

    <div id="stats-veteranas" class="mt-4 hidden">
      <div class="card-muted">
        <div class="flex items-center justify-between gap-2">
          <div class="font-semibold">Resumen Veteranas</div>
          <div class="text-xs text-slate-600">Umbrales: 75/80/85/90/95</div>
        </div>
        <div class="mt-3 grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
          <div><div class="text-xs text-slate-600">Jugadoras con edad</div><div class="text-lg font-bold" id="vStatEligible">--</div></div>
          <div><div class="text-xs text-slate-600">Seleccionadas</div><div class="text-lg font-bold" id="vStatSelected">--</div></div>
          <div><div class="text-xs text-slate-600">Media edad</div><div class="text-lg font-bold" id="vStatAvgAge">--</div></div>
          <div><div class="text-xs text-slate-600">Parejas generadas</div><div class="text-lg font-bold" id="vStatPairs">--</div></div>
        </div>
      </div>

      <div class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-4">
        <div class="card-muted">
          <div class="font-semibold">Jugadoras seleccionadas</div>
          <div class="text-xs text-slate-600 mt-1">Solo cuentan las que tienen edad y est√°n marcadas en ‚ÄúUsar‚Äù.</div>
          <div class="mt-3 overflow-auto border rounded-2xl bg-white">
            <table class="min-w-full text-sm">
              <thead class="bg-slate-100 text-slate-700">
                <tr>
                  <th class="text-left p-3">Nombre</th>
                  <th class="text-left p-3">Posici√≥n</th>
                  <th class="text-left p-3">Edad</th>
                </tr>
              </thead>
              <tbody id="vStatsPlayersTbody"></tbody>
            </table>
          </div>
        </div>

        <div class="card-muted">
          <div class="font-semibold">Parejas actuales</div>
          <div class="text-xs text-slate-600 mt-1">Suma de edades y validaci√≥n por umbral.</div>
          <div class="mt-3 space-y-3" id="vStatsPairsWrap"></div>
          <div class="mt-2 text-sm text-slate-600" id="vStatsMsg"></div>
        </div>
      </div>
    </div>

  </div>
</section>

<section class="tab-panel mt-6 hidden" id="tab-history">
<div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
<div class="bg-white border rounded-2xl shadow-sm p-4">
<h2 class="text-lg font-semibold">Jornadas guardadas</h2>
<div class="mt-4 space-y-3" id="journalsList"></div>
</div>
<div class="bg-white border rounded-2xl shadow-sm p-4">
<h2 class="text-lg font-semibold">Resumen</h2>
<div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm">
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Jugadoras</div>
<div class="text-xl font-bold" id="sumPlayers">0</div>
</div>
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Parejas hist√≥ricas</div>
<div class="text-xl font-bold" id="sumPairsHistory">0</div>
</div>
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Jornadas</div>
<div class="text-xl font-bold" id="sumJournals">0</div>
</div>
<div class="rounded-2xl border bg-slate-50 p-3">
<div class="text-slate-600">Rondas registradas</div>
<div class="text-xl font-bold" id="sumMatches">0</div>
</div>
</div>
<div class="mt-4 rounded-2xl border bg-white p-3 text-sm text-slate-700">
<div class="font-semibold">Evitar repetir parejas</div>
<div class="mt-4 rounded-2xl border bg-white p-4">
<div class="flex items-center justify-between gap-2">
<h3 class="font-semibold">Detalle de jornada</h3>
<button class="px-3 py-2 rounded-xl bg-white border hover:bg-slate-50 shadow-sm text-sm" id="btnClearJournalDetail">
                Cerrar
              </button>
</div>
<p class="text-sm text-slate-600 mt-1">
              Haz clic en una jornada de la izquierda para ver qui√©n jug√≥ cada partido y los resultados.
            </p>
<div class="mt-3" id="journalDetail"></div>
</div>
<p class="mt-2">Cada pareja se guarda como clave <span class="mono">A|B</span> (ordenada). Si existe, no se reutiliza.</p>
</div>
</div>
</div>
</section>
<!-- TAB 7: Veteranas -->
<section class="tab-panel mt-6 hidden" id="tab-veteranas">
  <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
    <div class="bg-white border rounded-2xl shadow-sm p-4">
      <h2 class="text-lg font-semibold">C√°lculo de parejas de Veteranas</h2>
      <p class="text-sm text-slate-600 mt-1">
        Genera 5 parejas cumpliendo suma de edades y posiciones (Izquierda/Derecha; Comod√≠n vale para ambas).
      </p>

      <div class="mt-4 space-y-3">
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
          <div>
            <label class="text-sm font-medium text-slate-700">Nombre</label>
            <input id="vName" class="mt-1 w-full border rounded-xl px-3 py-2" placeholder="Ej. Gaby" />
          </div>
          <div>
            <label class="text-sm font-medium text-slate-700">Posici√≥n</label>
            <select id="vSide" class="mt-1 w-full border rounded-xl px-3 py-2">
              <option value="L">Izquierda</option>
              <option value="R">Derecha</option>
              <option value="J">Comod√≠n</option>
            </select>
          </div>
          <div>
            <label class="text-sm font-medium text-slate-700">Edad (opcional)</label>
            <input id="vAge" class="mt-1 w-full border rounded-xl px-3 py-2" inputmode="numeric" type="number" min="0" placeholder="Ej. 42" />
          </div>
        </div>

        <div class="flex flex-wrap gap-2">
          <button id="btnAddVets" class="btn-success px-4 py-2 rounded-xl font-medium">A√±adir jugadora</button>
          <button id="btnRecalcVets" class="btn-primary px-4 py-2 rounded-xl font-medium">Recalcular parejas</button>
          <button id="btnClearVets" class="btn-danger px-4 py-2 rounded-xl font-medium">Borrar lista</button>
        </div>

        <div class="text-xs text-slate-500">
          Nota: si una jugadora no tiene edad, <b>no podr√° jugar Veteranas</b> (pero puede seguir en Americanas).
        </div>
      </div>
    </div>

    <div class="bg-white border rounded-2xl shadow-sm p-4 lg:col-span-2">
      <div class="flex items-center justify-between gap-2">
        <h3 class="text-lg font-semibold">Jugadoras (Veteranas)</h3>
        <span class="text-sm text-slate-600">Elegibles (con edad): <b id="vEligibleCount">0</b></span>
      </div>

      <div class="mt-3">
        <div class="flex flex-wrap items-center justify-between gap-2">
          <h3 class="text-lg font-semibold">Parejas generadas</h3>
          <div class="flex items-center gap-4">
            <span class="text-sm font-medium text-slate-700">Modo:</span>
            <label class="inline-flex items-center gap-2 text-sm">
              <input type="radio" name="vMode" value="auto" class="h-4 w-4 accent-sky-600" checked>
              <span>Autom√°tico</span>
            </label>
            <label class="inline-flex items-center gap-2 text-sm">
              <input type="radio" name="vMode" value="manual" class="h-4 w-4 accent-sky-600">
              <span>Manual</span>
            </label>
          </div>
          <span class="text-sm text-slate-600">Reglas: 5 partidos, umbrales 75/80/85/90/95</span>
        </div>

        <div class="mt-3 space-y-3" id="vPairsWrap"></div>

        <div class="mt-3 text-sm text-slate-600" id="vPairsMsg"></div>
      </div>
    <div class="mt-6 border-t pt-4">
        <h3 class="text-lg font-semibold">Jugadoras seleccionadas</h3>
        <div class="mt-3 overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="text-left text-slate-600 border-b">
              <th class="py-2 pr-3">Usar</th>
              <th class="py-2 pr-3">Nombre</th>
              <th class="py-2 pr-3">Posici√≥n</th>
              <th class="py-2 pr-3">Edad</th>
              <th class="py-2 pr-3"></th>
            </tr>
          </thead>
          <tbody id="vPlayersTbody"></tbody>
        </table>
      </div>
      </div>

      </div>
  </div>
</section>
<footer class="mt-12 text-xs text-slate-500">
      Funciona con doble clic en el HTML ¬∑ Todo se guarda en LocalStorage.
    </footer>
</div>
<script>

    /***********************************************************************
     * PASO A PASO (muy comentado):
     *
     * 1) Guardamos todo en "db" y lo persistimos en LocalStorage.
     * 2) Planificamos una jornada de 90 min dividida en "rondas".
     * 3) En cada ronda hay N pistas (partidos simult√°neos).
     * 4) Cada pista necesita 2 parejas ‚Üí 4 jugadoras.
     * 5) Por ronda usamos 4*N jugadoras, sin repetir dentro de la ronda.
     * 6) Evitamos repetir parejas (hist√≥rico global).
     * 7) Temporizador por ronda y resultados por jugadora.
     ***********************************************************************/

    const STORAGE_KEY = "padel_jornada_manager_v2_courts";
    let db = { players: [], pairHistory: [], journals: [], currentJournalId: null, veteranasPlayers: [], veteranasPairs: [], veteranasSeen: [], veteranasMeta: { noMore: false, lastMsg: "" }, veteranasMode: "auto", veteranasManual: { slots: [], pairs: [], msg: "" } };

    // ‚úÖ Estado de UI: qu√© jornada estamos viendo en detalle (no hace falta guardarlo en LocalStorage)
    let selectedJournalId = null;

    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));

    

    // --- Preferencias UI / scoring ---
    function getScoreMode() {
      const el = document.querySelector('input[name="scoreMode"]:checked');
      return el ? el.value : (db.settings?.scoreMode || "games");
    }

    function setScoreMode(mode) {
      db.settings = db.settings || {};
      db.settings.scoreMode = mode;
      save();
    }

    
    function updateScoreModeUI() {
      const mode = getScoreMode();
      const showGames = (mode === "games" || mode === "both");
      const showPoints = (mode === "points" || mode === "both");
      $$(".pairGamesWrap").forEach(el => el.style.display = showGames ? "" : "none");
      $$(".pairPointsWrap").forEach(el => el.style.display = showPoints ? "" : "none");
    }

    function applyScoreModeToRadios() {
      const mode = db.settings?.scoreMode || "games";
      const map = { games: "#scoreModeGames", points: "#scoreModePoints", both: "#scoreModeBoth" };
      const sel = map[mode] || "#scoreModeGames";
      const el = $(sel);
      if (el) el.checked = true;
    }

    function computeSuggestedRounds() {
      const j = ensureCurrentJournalDraft();
      const totalMin = Number($("#totalDurationMin")?.value || j.totalDurationMin || 90);
      const courts = Number($("#courtsCount")?.value || j.courtCount || 3);
      // Jugadoras seleccionadas: si no hay selecci√≥n a√∫n, usamos includeCount o total
      const selected = (j.includeIds && j.includeIds.length) ? j.includeIds.length : Number($("#includeCount")?.value || db.players.length || 0);
      const playersPerRound = Math.max(1, courts * 4);

      // Heur√≠stica 1: rondas que den ~15 min por ronda (clamp 10..25)
      let rounds = Math.round(totalMin / 15);
      rounds = Math.max(1, rounds);
      let perRound = totalMin / rounds;
      if (perRound < 10) rounds = Math.max(1, Math.floor(totalMin / 10));
      if (perRound > 25) rounds = Math.max(1, Math.ceil(totalMin / 25));

      // Heur√≠stica 2: que cada jugadora juegue al menos ~3 partidos (si hay m√°s jugadoras que huecos)
      if (selected > 0) {
        const minMatchesTarget = 3;
        const roundsForMinMatches = Math.ceil((minMatchesTarget * selected) / playersPerRound);
        // Subimos rondas si cabe sin bajar de 10 min por ronda
        const maxRoundsByTime = Math.max(1, Math.floor(totalMin / 10));
        rounds = Math.min(Math.max(rounds, roundsForMinMatches), maxRoundsByTime);
      }

      perRound = totalMin / rounds;
      return { rounds, perRoundMin: perRound, selected, playersPerRound };
    }

    function renderSuggestedRounds() {
      const el = $("#suggestedRoundsLabel");
      const el2 = $("#suggestedRoundsExplain");
      if (!el || !el2) return;
      const s = computeSuggestedRounds();
      el.textContent = `${s.rounds} rondas (~${Math.round(s.perRoundMin)} min/ronda)`;
      if (s.selected > 0) {
        const expectedMatchesPerPlayer = (s.rounds * s.playersPerRound) / s.selected;
        el2.textContent = `Con ${s.selected} jugadoras y ${Math.round(s.playersPerRound/4)} pistas, cada jugadora jugar√° ~${expectedMatchesPerPlayer.toFixed(1)} partidos de media.`;
      } else {
        el2.textContent = `Ajusta jugadoras/pistas si quieres una sugerencia m√°s precisa.`;
      }
    }

    function applySuggestedRounds() {
      const s = computeSuggestedRounds();
      const inp = $("#matchCount");
      if (inp) inp.value = String(s.rounds);
      renderMatchDurationPreview();
      savePlanDraftFromUI();
      save();
      render();
    }

    // --- Estad√≠sticas (se calculan desde resultados guardados) ---
    function computeStats() {
      const stats = new Map();
      for (const p of db.players) {
        stats.set(p.id, {
          id: p.id, name: p.name, role: p.role,
          played: 0, wins: 0, losses: 0,
          gamesFor: 0, gamesAgainst: 0,
          pointsFor: 0, pointsAgainst: 0,
        });
      }

      const pairAgg = new Map(); // "id1|id2" -> {wins,losses,gamesDiff,pointsDiff,played}

      const j = getCurrentJournal();
      const rounds = (j && j.schedule) ? j.schedule : [];
      let matchesTotal = 0, gamesTotal = 0, pointsTotal = 0;

      for (const r of rounds) {
        if (!r.resultSaved || !r.result || !Array.isArray(r.result.courts)) continue;
        for (const c of r.result.courts) {
          matchesTotal++;
          const aIds = c.teamA?.playerIds || [];
          const bIds = c.teamB?.playerIds || [];
          const gA = Number(c.teamA?.games || 0), gB = Number(c.teamB?.games || 0);
          const pA = Number(c.teamA?.points || 0), pB = Number(c.teamB?.points || 0);

          gamesTotal += (gA + gB);
          pointsTotal += (pA + pB);

          let winner = null; // "A"|"B"|null
          if (gA !== gB) winner = gA > gB ? "A" : "B";
          else if (pA !== pB) winner = pA > pB ? "A" : "B";

          // jugadores A
          for (const pid of aIds) {
            const s = stats.get(pid);
            if (!s) continue;
            s.played++;
            if (winner === "A") s.wins++; else if (winner === "B") s.losses++;
            s.gamesFor += gA; s.gamesAgainst += gB;
            s.pointsFor += pA; s.pointsAgainst += pB;
          }
          // jugadores B
          for (const pid of bIds) {
            const s = stats.get(pid);
            if (!s) continue;
            s.played++;
            if (winner === "B") s.wins++; else if (winner === "A") s.losses++;
            s.gamesFor += gB; s.gamesAgainst += gA;
            s.pointsFor += pB; s.pointsAgainst += pA;
          }

          // parejas
          const pairKeyA = pairKey(aIds[0], aIds[1]);
          const pairKeyB = pairKey(bIds[0], bIds[1]);

          const updPair = (k, isWin, gd, pd) => {
            if (!k) return;
            const o = pairAgg.get(k) || { played:0,wins:0,losses:0,gamesDiff:0,pointsDiff:0 };
            o.played++;
            if (isWin === true) o.wins++;
            if (isWin === false) o.losses++;
            o.gamesDiff += gd;
            o.pointsDiff += pd;
            pairAgg.set(k, o);
          };

          const gdA = gA - gB, gdB = gB - gA;
          const pdA = pA - pB, pdB = pB - pA;
          updPair(pairKeyA, winner==="A" ? true : winner==="B" ? false : null, gdA, pdA);
          updPair(pairKeyB, winner==="B" ? true : winner==="A" ? false : null, gdB, pdB);
        }
      }

      const statRows = Array.from(stats.values());
      statRows.sort((x,y)=>{
        // Partidos: wins desc, losses asc
        if (y.wins !== x.wins) return y.wins - x.wins;
        if (x.losses !== y.losses) return x.losses - y.losses;
        const xGd = (x.gamesFor - x.gamesAgainst), yGd = (y.gamesFor - y.gamesAgainst);
        if (yGd !== xGd) return yGd - xGd;
        const xPd = (x.pointsFor - x.pointsAgainst), yPd = (y.pointsFor - y.pointsAgainst);
        if (yPd !== xPd) return yPd - xPd;
        if (y.gamesFor !== x.gamesFor) return y.gamesFor - x.gamesFor;
        if (y.pointsFor !== x.pointsFor) return y.pointsFor - x.pointsFor;
        return x.name.localeCompare(y.name);
      });

      const topPairs = Array.from(pairAgg.entries()).map(([k,v])=>({key:k,...v}));
      topPairs.sort((a,b)=>{
        if (b.wins !== a.wins) return b.wins - a.wins;
        if (a.losses !== b.losses) return a.losses - b.losses;
        if (b.gamesDiff !== a.gamesDiff) return b.gamesDiff - a.gamesDiff;
        if (b.pointsDiff !== a.pointsDiff) return b.pointsDiff - a.pointsDiff;
        return a.key.localeCompare(b.key);
      });

      const roundsPlayed = rounds.filter(r=>r.resultSaved).length;

      return { statRows, topPairs, roundsPlayed, matchesTotal, gamesTotal, pointsTotal };
    }

    function renderStatsTab() {
      const { statRows, topPairs, roundsPlayed, matchesTotal, gamesTotal, pointsTotal } = computeStats();
      typeof setStatsSub === "function" && setStatsSub(currentStatsSub || "americanas");

      const tbody = $("#statsTable");
      if (tbody) {
        tbody.innerHTML = statRows.map((s, i) => {
          const winPct = s.played ? Math.round((s.wins / s.played) * 100) : 0;
          return `
            <tr class="border-t">
              <td class="p-3">${i+1}</td>
              <td class="p-3 font-medium">${escapeHtml(s.name)}</td>
              <td class="p-3">${roleLabel(s.role)}</td>
              <td class="p-3">${s.played}</td>
              <td class="p-3">${s.wins}</td>
              <td class="p-3">${s.losses}</td>
              <td class="p-3">${s.gamesFor}-${s.gamesAgainst}</td>
              <td class="p-3">${s.pointsFor}-${s.pointsAgainst}</td>
              <td class="p-3">${winPct}%</td>
            </tr>
          `;
        }).join("");
      }

      const topEl = $("#topPairsList");
      if (topEl) {
        if (!topPairs.length) {
          topEl.innerHTML = `<div class="text-slate-500 text-sm">A√∫n no hay resultados guardados.</div>`;
        } else {
          const items = topPairs.slice(0, 8).map((p, idx) => {
            const [id1,id2] = p.key.split("|");
            const a = getPlayer(id1), b = getPlayer(id2);
            const name = `${a?.name||"¬ø?"} + ${b?.name||"¬ø?"}`;
            return `<div class="flex items-center justify-between gap-3 border-b last:border-b-0 py-2">
              <div class="text-sm"><span class="font-semibold">#${idx+1}</span> ${escapeHtml(name)}</div>
              <div class="text-xs text-slate-600">${p.wins}-${p.losses} ¬∑ ŒîJ ${p.gamesDiff} ¬∑ ŒîP ${p.pointsDiff}</div>
            </div>`;
          }).join("");
          topEl.innerHTML = `<div class="rounded-xl border bg-white">${items}</div>`;
        }
      }

      $("#statRoundsPlayed2") && ($("#statRoundsPlayed2").textContent = String(roundsPlayed));
      $("#statMatchesTotal") && ($("#statMatchesTotal").textContent = String(matchesTotal));
      $("#statGamesTotal") && ($("#statGamesTotal").textContent = String(gamesTotal));
      $("#statPointsTotal") && ($("#statPointsTotal").textContent = String(pointsTotal));

      // ---- Estad√≠sticas Veteranas (sin resultados: resumen de selecci√≥n y parejas actuales) ----
      const vAll = (db.veteranasPlayers || []);
      const vEligible = vAll.filter(p => Number.isFinite(p.age) && p.age > 0);
      const vSelected = vEligible.filter(p => p.use !== false); // por defecto true
      const avgAge = vSelected.length ? Math.round(vSelected.reduce((a,p)=>a+p.age,0) / vSelected.length) : 0;

      $("#vStatEligible") && ($("#vStatEligible").textContent = String(vEligible.length));
      $("#vStatSelected") && ($("#vStatSelected").textContent = String(vSelected.length));
      $("#vStatAvgAge") && ($("#vStatAvgAge").textContent = vSelected.length ? String(avgAge) : "--");
      $("#vStatPairs") && ($("#vStatPairs").textContent = db.veteranasPairs?.length ? String(db.veteranasPairs.length) : "0");

      const vTbody = $("#vStatsPlayersTbody");
      if (vTbody) {
        const rows = vSelected.sort((a,b)=>b.age-a.age).map(p => `
          <tr class="border-t">
            <td class="p-3 font-medium">${escapeHtml(p.name)}</td>
            <td class="p-3">${roleLabel(p.side)}</td>
            <td class="p-3">${p.age}</td>
          </tr>
        `).join("");
        vTbody.innerHTML = rows || `<tr class="border-t"><td class="p-3 text-slate-500" colspan="3">No hay jugadoras seleccionadas con edad.</td></tr>`;
      }

      const vPairsEl = $("#vStatsPairsWrap");
      const vMsgEl = $("#vStatsMsg");
      if (vPairsEl) {
        const thresholds = [75,80,85,90,95];
        const pairs = db.veteranasPairs || [];
        if (!pairs.length) {
          vPairsEl.innerHTML = `<div class="text-slate-500 text-sm">A√∫n no hay parejas generadas.</div>`;
          vMsgEl && (vMsgEl.textContent = "");
        } else {
          vPairsEl.innerHTML = pairs.map((pair, idx) => {
            const t = thresholds[idx] ?? 0;
            const sum = (pair.a?.age||0) + (pair.b?.age||0);
            const ok = sum >= t;
            return `<div class="border rounded-2xl bg-white p-3">
              <div class="flex items-center justify-between gap-2">
                <div class="font-semibold">Pareja ${idx+1} (‚â• ${t} a√±os)</div>
                <div class="text-sm">${sum} a√±os <span class="ml-2 inline-flex items-center px-2 py-0.5 rounded-full text-xs ${ok ? "bg-green-100 text-green-700" : "bg-rose-100 text-rose-700"}">${ok ? "OK" : "NO"}</span></div>
              </div>
              <div class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-2 text-sm">
                <div class="border rounded-xl p-2">
                  <div class="font-medium">${escapeHtml(pair.a?.name||"¬ø?")}</div>
                  <div class="text-xs text-slate-600">${roleLabel(pair.a?.side)} ¬∑ ${pair.a?.age||"?"} a√±os</div>
                </div>
                <div class="border rounded-xl p-2">
                  <div class="font-medium">${escapeHtml(pair.b?.name||"¬ø?")}</div>
                  <div class="text-xs text-slate-600">${roleLabel(pair.b?.side)} ¬∑ ${pair.b?.age||"?"} a√±os</div>
                </div>
              </div>
            </div>`;
          }).join("");
          vMsgEl && (vMsgEl.textContent = db.veteranasMeta?.lastMsg || "");
        }
      }
    }

function uid(prefix="id") { return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); }

    function roleLabel(r) { return r === "L" ? "IZQUIERDA" : r === "R" ? "DERECHA" : "COMOD√çN"; }

    function escapeHtml(str) {
      return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function fmtMMSS(sec) {
      sec = Math.max(0, Math.floor(sec));
      const m = String(Math.floor(sec / 60)).padStart(2,"0");
      const s = String(sec % 60).padStart(2,"0");
      return `${m}:${s}`;
    }

    function pairKey(aId, bId) { return [aId, bId].sort().join("|"); }

    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function getPlayer(id) { return db.players.find(p => p.id === id) || null; }

    /***********************************************************************
     * üîî SONIDO (timbre) al finalizar el tiempo
     *
     * Importante: en navegadores modernos el audio suele requerir interacci√≥n
     * del usuario antes (por ejemplo, haber pulsado "Iniciar"). Como aqu√≠
     * siempre se inicia el timer con un click, normalmente sonar√° sin problema.
     ***********************************************************************/
    let audioCtx = null;

    function playBeep() {
      try {
        // Creamos el contexto de audio solo la primera vez (mejor rendimiento).
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Si el contexto est√° "suspendido" (a veces pasa), lo reanudamos.
        if (audioCtx.state === "suspended") audioCtx.resume();

        // Un oscilador genera una onda (un tono). Lo conectamos al altavoz.
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        // Frecuencia del tono (Hz). 880 = agudo, f√°cil de o√≠r.
        osc.frequency.value = 880;
        osc.type = "sine";

        // Volumen: bajito para no molestar.
        gain.gain.value = 0.15;

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        // Arrancamos y paramos muy r√°pido para hacer "beep".
        osc.start();
        osc.stop(audioCtx.currentTime + 0.25);
      } catch (e) {
        // Si el navegador no permite audio, simplemente no hacemos nada.
        console.warn("No se pudo reproducir el timbre:", e);
      }
    }


    function load() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try { db = { ...db, ...JSON.parse(raw) }; } catch (e) { console.warn("LocalStorage inv√°lido:", e); }
    }

    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(db));
      renderAll();
    }

    function setTab(name) {
      $$(".tab-panel").forEach(p => p.classList.add("hidden"));
      $("#tab-" + name).classList.remove("hidden");
      $$(".tab").forEach(b => b.classList.remove("tab-active"));
      const btn = document.querySelector(`.tab[data-tab="${name}"]`);
      if (btn) btn.classList.add("tab-active");

      // T√≠tulo din√°mico: en Veteranas mostramos un encabezado espec√≠fico
      const titleEl = $("#appTitleText");
      const subEl = $("#appSubtitleText");
      if (titleEl) {
        if (name === "veteranas") {
          titleEl.textContent = "C√°lculo de parejas de Veteranas";
          subEl && (subEl.textContent = "Generador de 5 parejas por umbrales de edad y posiciones (IZQ/DER; comod√≠n vale para ambas).");
        } else {
          titleEl.textContent = "Americanas Gaby";
          subEl && (subEl.textContent = "Pistas simult√°neas ¬∑ parejas IZQ‚ÄìDER ¬∑ sin repetir parejas ¬∑ ranking final");
        }
      }

      // Render bajo demanda para evitar c√°lculos innecesarios
      if (name === "ranking") renderRanking();
      if (name === "stats") renderStatsTab();
      if (name === "veteranas") renderVeteranas();
    }


    // Subpesta√±as de Estad√≠sticas: Americanas / Veteranas
    let currentStatsSub = "americanas";
    function setStatsSub(name) {
      currentStatsSub = name;
      const a = $("#stats-americanas");
      const v = $("#stats-veteranas");
      if (a && v) {
        a.classList.toggle("hidden", name !== "americanas");
        v.classList.toggle("hidden", name !== "veteranas");
      }
      $$(".stats-tab").forEach(b => {
        b.classList.toggle("tab-active", b.dataset.stats === name);
      });
    }

    function renderAll() {
      renderPlayers();
      renderIncludeGrid();
      renderPlanDerived();
      renderSchedule();
      renderCurrentRound();
      restoreTimerFromStorage();
      renderRanking();
      renderHistory();
      renderSummary();
      renderJournalDetail();
      renderVeteranas();
    }

    function renderPlayers() {
      $("#playersCount").textContent = `${db.players.length} jugadoras`;
      const rows = db.players.slice().sort((a,b)=>a.name.localeCompare(b.name,"es")).map(p => `
        <tr class="border-t">
          <td class="p-3 font-medium">${escapeHtml(p.name)}</td>
          <td class="p-3">${roleLabel(p.role)}</td>
          <td class="p-3">${p.pointsTotal || 0}</td>
          <td class="p-3 text-right">
            <button class="btnEditPlayer px-3 py-1 rounded-lg bg-white border hover:bg-slate-50" data-id="${p.id}">Editar</button>
            <button class="btnDelPlayer px-3 py-1 rounded-lg bg-rose-600 text-white hover:bg-rose-700 ml-2" data-id="${p.id}">Borrar</button>
          </td>
        </tr>
      `).join("");
      $("#playersTable").innerHTML = rows || `<tr><td class="p-3 text-slate-500" colspan="4">A√∫n no hay jugadoras.</td></tr>`;
      $$(".btnDelPlayer").forEach(b => b.addEventListener("click", () => delPlayer(b.dataset.id)));
      $$(".btnEditPlayer").forEach(b => b.addEventListener("click", () => editPlayerPrompt(b.dataset.id)));
    }

    function renderIncludeGrid() {
      const wrap = $("#includePlayersGrid");
      if (!db.players.length) { wrap.innerHTML = `<div class="text-sm text-slate-500">A√±ade jugadoras en "Jugadoras".</div>`; return; }
      const current = getCurrentJournal();
      const selected = new Set(current?.includeIds || []);
      wrap.innerHTML = db.players.slice().sort((a,b)=>a.name.localeCompare(b.name,"es")).map(p => {
        const checked = selected.has(p.id) ? "checked" : "";
        return `
          <label class="flex items-center gap-2 rounded-xl border bg-white p-2 cursor-pointer hover:bg-slate-50">
            <input type="checkbox" class="includeChk" data-id="${p.id}" ${checked} />
            <div class="flex-1">
              <div class="text-sm font-medium">${escapeHtml(p.name)}</div>
              <div class="text-xs text-slate-500">${roleLabel(p.role)}</div>
            </div>
          </label>
        `;
      }).join("");
      $$(".includeChk").forEach(chk => chk.addEventListener("change", () => {
        let j = getCurrentJournal();
      // Si la jornada actual ya tiene rondas (por ejemplo, ya se jug√≥), creamos una NUEVA jornada.
      if (j && (j.schedule?.length || 0) > 0) {
        j = createNewJournalDraft();
      } else {
        j = ensureCurrentJournalDraft();
      }
        const id = chk.dataset.id;
        const set = new Set(j.includeIds);
        chk.checked ? set.add(id) : set.delete(id);
        j.includeIds = Array.from(set);
        save();
      }));
    }

    function renderPlanDerived() {
  const rounds = Number($("#matchCount").value || 0);
  const courts = Number($("#courtCount").value || 0);
  const totalMin = Number($("#totalDurationMin").value || 90);

  $("#matchDurationLabel").textContent = rounds > 0 ? fmtMMSS(Math.floor((totalMin * 60) / rounds)) : "--:--";
  $("#totalDurationHint").textContent = String(totalMin);

  const needed = courts > 0 ? 4 * courts : 0;
  $("#needPlayersHint").textContent = needed ? `M√≠nimo: ${needed} (4 √ó ${courts} pistas)` : "M√≠nimo: --";
  renderSuggestedRounds();
}

    function renderSchedule() {
      const j = getCurrentJournal();
      const wrap = $("#scheduleList");
      if (!j || !j.schedule?.length) {
        wrap.innerHTML = `<div class="text-sm text-slate-500">A√∫n no has generado una jornada.</div>`;
        $("#statPlanned").textContent = "0";
        $("#statDone").textContent = "0";
        $("#statDuration").textContent = "--:--";
        return;
      }

      wrap.innerHTML = j.schedule.map((round, idx) => {
        const done = round.resultSaved ? "‚úÖ" : "‚è≥";
        const courtsHtml = round.courts.map(c => {
          const aL = getPlayer(c.pairA.leftId), aR = getPlayer(c.pairA.rightId);
          const bL = getPlayer(c.pairB.leftId), bR = getPlayer(c.pairB.rightId);
          return `
            <div class="rounded-xl border p-2 mt-2">
              <div class="font-semibold">Pista ${c.courtNo}</div>
              <div class="text-sm mt-1">
                <div><span class="font-medium">Pareja A:</span> ${escapeHtml(aL?.name||"¬ø?")} (I) - ${escapeHtml(aR?.name||"¬ø?")} (D)</div>
                <div><span class="font-medium">Pareja B:</span> ${escapeHtml(bL?.name||"¬ø?")} (I) - ${escapeHtml(bR?.name||"¬ø?")} (D)</div>
              </div>
            </div>
          `;
        }).join("");

        return `
          <div class="journalCard rounded-2xl border bg-white p-3 cursor-pointer hover:bg-slate-50" data-id="${j.id}">
            <div class="flex items-center justify-between">
              <div class="font-semibold">Ronda ${idx+1} ${done}</div>
              <div class="text-xs text-slate-500">duraci√≥n: ${fmtMMSS(j.durationSec)} ¬∑ pistas: ${round.courts.length}</div>
            </div>
            ${courtsHtml}
          </div>
        `;
      }).join("");

      $("#statPlanned").textContent = j.schedule.length;
      $("#statDone").textContent = j.schedule.filter(x => x.resultSaved).length;
      $("#statDuration").textContent = fmtMMSS(j.durationSec);
    }

    function renderCurrentRound() {
      const j = getCurrentJournal();
      if (!j || !j.schedule?.length) {
        $("#currentMatchIndexLabel").textContent = "Ronda -/-";
        $("#currentMatchPairs").innerHTML = `<div class="text-sm text-slate-500">Genera la jornada en "Jornada".</div>`;
        $("#resultsGrid").innerHTML = "";
        disableResultsUI(true);
        return;
      }

      const idx = j.currentRoundIndex || 0;
      const round = j.schedule[idx];
      $("#currentMatchIndexLabel").textContent = `Ronda ${idx+1}/${j.schedule.length}`;

      $("#currentMatchPairs").innerHTML = round.courts.map(c => {
        const aL = getPlayer(c.pairA.leftId), aR = getPlayer(c.pairA.rightId);
        const bL = getPlayer(c.pairB.leftId), bR = getPlayer(c.pairB.rightId);
        return `
          <div class="rounded-xl border p-3">
            <div class="font-semibold">Pista ${c.courtNo}</div>
            <div class="mt-2">
              <div class="rounded-lg border p-2">
                <div class="font-medium">Pareja A</div>
                <div>${escapeHtml(aL?.name||"¬ø?")} (I) - ${escapeHtml(aR?.name||"¬ø?")} (D)</div>
              </div>
              <div class="rounded-lg border p-2 mt-2">
                <div class="font-medium">Pareja B</div>
                <div>${escapeHtml(bL?.name||"¬ø?")} (I) - ${escapeHtml(bR?.name||"¬ø?")} (D)</div>
              </div>
            </div>
          </div>
        `;
      }).join("");

      // ‚úÖ Resultado configurable: Juegos / Puntos / Ambos
      const pairCards = [];
      for (const c of round.courts) {
        const aL = getPlayer(c.pairA.leftId), aR = getPlayer(c.pairA.rightId);
        const bL = getPlayer(c.pairB.leftId), bR = getPlayer(c.pairB.rightId);

        pairCards.push({
          courtNo: c.courtNo,
          team: "A",
          label: `Pista ${c.courtNo} ¬∑ Pareja A`,
          names: `${aL?.name||"¬ø?"} (I) - ${aR?.name||"¬ø?"} (D)`,
          playerIds: [c.pairA.leftId, c.pairA.rightId]
        });

        pairCards.push({
          courtNo: c.courtNo,
          team: "B",
          label: `Pista ${c.courtNo} ¬∑ Pareja B`,
          names: `${bL?.name||"¬ø?"} (I) - ${bR?.name||"¬ø?"} (D)`,
          playerIds: [c.pairB.leftId, c.pairB.rightId]
        });
      }

      $("#resultsGrid").innerHTML = `
        <div class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
          ${pairCards.map((pi) => `
            <div class="pairCard rounded-2xl border bg-slate-50 p-4"
                 data-court="${pi.courtNo}" data-team="${pi.team}" data-players="${pi.playerIds.join(",")}">
              <div class="text-sm font-semibold">${escapeHtml(pi.label)}</div>
              <div class="text-xs text-slate-600 mt-1">${escapeHtml(pi.names)}</div>

              <div class="pairGamesWrap mt-3">
                <label class="block text-xs text-slate-600">Juegos</label>
                <input type="number" min="0" step="1" inputmode="numeric" pattern="[0-9]*"
                       class="pairGamesInput w-full rounded-xl border px-3 py-3 mt-1"
                       placeholder="0" disabled />
              </div>

              <div class="pairPointsWrap mt-3">
                <label class="block text-xs text-slate-600">Puntos</label>
                <input type="number" min="0" step="1" inputmode="numeric" pattern="[0-9]*"
                       class="pairPointsInput w-full rounded-xl border px-3 py-3 mt-1"
                       placeholder="0" disabled />
              </div>
            </div>
          `).join("")}
        </div>
        <p class="text-xs text-slate-500 mt-3">
          Nota: introduce el marcador por pareja. El sistema calcular√° ranking por <b>Partidos</b> ‚Üí <b>Juegos</b> ‚Üí <b>Puntos</b>.
        </p>
      `;

      applyScoreModeToRadios();
      updateScoreModeUI();


      if (!$("#resultDate").value) $("#resultDate").value = new Date().toISOString().slice(0,10);

      if (round.resultSaved) {
        showMatchMessage("info", "Esta ronda ya tiene resultado guardado. Puedes pasar a la siguiente.");
        disableResultsUI(true);
        $("#btnNextMatch").disabled = false;
      } else {
        clearMatchMessage();
        disableResultsUI(true);
      }

      $("#statPlanned").textContent = j.schedule.length;
      $("#statDone").textContent = j.schedule.filter(x => x.resultSaved).length;
      $("#statDuration").textContent = fmtMMSS(j.durationSec);
    }

    
function renderRanking() {
      const { statRows } = computeStats();

      const rows = statRows.map((s,i)=>`
        <tr class="border-t">
          <td class="p-3">${i+1}</td>
          <td class="p-3 font-medium">${escapeHtml(s.name)}</td>
          <td class="p-3">${roleLabel(s.role)}</td>
          <td class="p-3">${s.wins}-${s.losses}</td>
          <td class="p-3">${s.gamesFor}-${s.gamesAgainst}</td>
          <td class="p-3">${s.pointsFor}-${s.pointsAgainst}</td>
          <td class="p-3">${s.played}</td>
        </tr>
      `).join("");

      $("#rankingTable").innerHTML = rows || `<tr><td class="p-3 text-slate-500" colspan="7">A√∫n no hay datos.</td></tr>`;

      $("#rankingNote").textContent = "Orden: Partidos (G/P) ‚Üí Juegos ‚Üí Puntos.";
    }


    function renderHistory() {
      const wrap = $("#journalsList");
      if (!db.journals.length) { wrap.innerHTML = `<div class="text-sm text-slate-500">A√∫n no hay jornadas guardadas.</div>`; return; }
      wrap.innerHTML = db.journals.slice().sort((a,b)=>b.createdAt-a.createdAt).map(j => {
        const done = j.schedule?.filter(x => x.resultSaved).length || 0;
        const total = j.schedule?.length || 0;
        const active = (db.currentJournalId === j.id) ? " (ACTIVA)" : "";
        return `
            <div class="journalCard rounded-2xl border bg-white p-3 cursor-pointer hover:bg-slate-50" data-id="${j.id}">
            <div class="flex items-center justify-between gap-2">
              <div>
                <div class="font-semibold">Jornada ${new Date(j.createdAt).toLocaleString("es-ES")} ${active}</div>
                <div class="text-xs text-slate-500">jugadoras: ${j.includeIds?.length||0} ¬∑ rondas: ${total} ¬∑ completadas: ${done} ¬∑ pistas: ${j.courtCount||1} ¬∑ duraci√≥n: ${fmtMMSS(j.durationSec||0)}</div>
              </div>
              <div class="flex gap-2">
                <button class="btnActivateJournal px-3 py-1 rounded-lg bg-slate-900 text-white hover:bg-slate-800 text-sm" data-id="${j.id}">Activar</button>
                  <button class="btnConsultJournal px-3 py-1 rounded-lg bg-blue-600 text-white hover:bg-blue-700 text-sm" data-id="${j.id}">Consultar</button>
                <button class="btnDeleteJournal px-3 py-1 rounded-lg bg-rose-600 text-white hover:bg-rose-700 text-sm" data-id="${j.id}">Borrar</button>
              </div>
            </div>
          </div>
        `;
      }).join("");
      $$(".btnActivateJournal").forEach(b => b.addEventListener("click", (ev) => {
        ev.stopPropagation(); // ‚úÖ para que NO abra el detalle al pulsar "Activar"
        activateJournal(b.dataset.id);
      }));
      $$(".btnDeleteJournal").forEach(b => b.addEventListener("click", (ev) => {
        ev.stopPropagation(); // ‚úÖ para que NO abra el detalle al pulsar "Borrar"
        deleteJournal(b.dataset.id);

      $$(".btnConsultJournal").forEach(b => b.addEventListener("click", (ev) => {
        ev.stopPropagation(); // ‚úÖ no queremos activar el click de la tarjeta
        selectedJournalId = b.dataset.id;
        renderJournalDetail();

        // Opcional: bajamos el scroll para que se vea el detalle en pantallas largas
        const detail = $("#journalDetail");
        if (detail) detail.scrollIntoView({ behavior: "smooth", block: "start" });
      }));
      }));

      // ‚úÖ Click en la tarjeta de jornada: muestra el detalle
      $$(".journalCard").forEach(card => card.addEventListener("click", () => {
        selectedJournalId = card.dataset.id;
        renderJournalDetail();
      }));
    }

    /***********************************************************************
     * üìå DETALLE DE JORNADA (Historial)
     *
     * - Al hacer clic en una jornada, mostramos cada ronda.
     * - Para cada pista, ense√±amos Pareja A y Pareja B, qui√©n jug√≥ y los puntos.
     ***********************************************************************/
    function renderJournalDetail() {
      const box = $("#journalDetail");
      if (!box) return;

      if (!selectedJournalId) {
        box.innerHTML = `<div class="text-sm text-slate-500">No hay ninguna jornada seleccionada.</div>`;
        return;
      }

      const j = db.journals.find(x => x.id === selectedJournalId);
      if (!j) {
        box.innerHTML = `<div class="text-sm text-slate-500">La jornada seleccionada ya no existe.</div>`;
        return;
      }

      const totalRounds = j.schedule?.length || 0;
      const doneRounds = j.schedule?.filter(r => r.resultSaved).length || 0;

      const header = `
        <div class="rounded-xl border bg-slate-50 p-3">
          <div class="font-semibold">Jornada ${new Date(j.createdAt).toLocaleString("es-ES")}${db.currentJournalId===j.id ? " (ACTIVA)" : ""}</div>
          <div class="text-xs text-slate-600 mt-1">
            pistas: ${j.courtCount || 1} ¬∑ jugadoras incluidas: ${j.includeIds?.length || 0} ¬∑ rondas: ${totalRounds} ¬∑ completadas: ${doneRounds} ¬∑ duraci√≥n/ronda: ${fmtMMSS(j.durationSec || 0)}
          </div>
        </div>
      `;

      if (!totalRounds) {
        box.innerHTML = header + `<div class="text-sm text-slate-500 mt-3">Esta jornada no tiene rondas planificadas.</div>`;
        return;
      }

      const roundsHtml = (j.schedule || []).map((round, idx) => {
        const hasResult = !!round.resultSaved && !!round.result;
        const date = hasResult ? (round.result.date || "") : "";
        const comment = hasResult ? (round.result.comment || "") : "";
        const pointsMap = hasResult ? (round.result.points || {}) : {};

        const courtsHtml = (round.courts || []).map(c => {
          const aL = getPlayer(c.pairA.leftId), aR = getPlayer(c.pairA.rightId);
          const bL = getPlayer(c.pairB.leftId), bR = getPlayer(c.pairB.rightId);

          // Puntos por pareja: como se introducen por pareja, podemos leer el valor de cualquiera de las dos jugadoras.
          const ptsA = hasResult ? Number(pointsMap[c.pairA.leftId] || 0) : "";
          const ptsB = hasResult ? Number(pointsMap[c.pairB.leftId] || 0) : "";

          return `
            <div class="rounded-xl border p-3 mt-2">
              <div class="font-semibold">Pista ${c.courtNo}</div>

              <div class="mt-2 grid grid-cols-1 md:grid-cols-2 gap-2">
                <div class="rounded-lg border bg-white p-2">
                  <div class="text-sm font-medium">Pareja A</div>
                  <div class="text-sm">${escapeHtml(aL?.name||"¬ø?" )} (I) - ${escapeHtml(aR?.name||"¬ø?" )} (D)</div>
                  <div class="text-xs text-slate-600 mt-1">Puntos pareja: <b>${hasResult ? ptsA : "-"}</b></div>
                </div>

                <div class="rounded-lg border bg-white p-2">
                  <div class="text-sm font-medium">Pareja B</div>
                  <div class="text-sm">${escapeHtml(bL?.name||"¬ø?" )} (I) - ${escapeHtml(bR?.name||"¬ø?" )} (D)</div>
                  <div class="text-xs text-slate-600 mt-1">Puntos pareja: <b>${hasResult ? ptsB : "-"}</b></div>
                </div>
              </div>
            </div>
          `;
        }).join("");

        return `
          <div class="rounded-2xl border bg-white p-3 mt-3">
            <div class="flex items-center justify-between gap-2">
              <div class="font-semibold">Ronda ${idx+1} ${hasResult ? "‚úÖ" : "‚è≥"}</div>
              <div class="text-xs text-slate-600">${hasResult ? `fecha: ${escapeHtml(date)}` : "sin resultado"}</div>
            </div>
            ${hasResult && comment ? `<div class="text-xs text-slate-600 mt-2">Comentario: ${escapeHtml(comment)}</div>` : ""}
            ${courtsHtml}
          </div>
        `;
      }).join("");

      box.innerHTML = header + roundsHtml;
    }

    function renderSummary() {
      $("#sumPlayers").textContent = db.players.length;
      $("#sumPairsHistory").textContent = db.pairHistory.length;
      $("#sumJournals").textContent = db.journals.length;
      const rounds = db.journals.reduce((acc, j) => acc + (j.schedule?.length || 0), 0);
      $("#sumMatches").textContent = rounds;
    }

    function addPlayer() {
      const name = ($("#playerName").value || "").trim();
      const role = $("#playerRole").value;
      if (!name) return alert("Introduce un nombre.");
      db.players.push({ id: uid("p"), name, role, pointsTotal: 0 });
      $("#playerName").value = "";
      $("#playerRole").value = "L";
      save();
    }

    function delPlayer(id) {
      const p = getPlayer(id);
      if (!p) return;
      if (!confirm(`¬øBorrar jugadora "${p.name}"?`)) return;
      db.players = db.players.filter(x => x.id !== id);

      db.journals = db.journals.map(j => {
        const includeIds = (j.includeIds || []).filter(pid => pid !== id);
        const schedule = (j.schedule || []).filter(r => {
          const ids = [];
          for (const c of (r.courts || [])) ids.push(c.pairA.leftId, c.pairA.rightId, c.pairB.leftId, c.pairB.rightId);
          return !ids.includes(id);
        });
        return { ...j, includeIds, schedule };
      });

      save();
    }

    function editPlayerPrompt(id) {
      const p = getPlayer(id);
      if (!p) return;
      const name = prompt("Nombre:", p.name);
      if (name === null) return;
      const role = prompt("Rol (L=Izquierda, R=Derecha, C=Comod√≠n):", p.role);
      if (role === null) return;
      const r = role.trim().toUpperCase();
      if (!["L","R","C"].includes(r)) return alert("Rol inv√°lido. Usa L, R o C.");
      p.name = name.trim() || p.name;
      p.role = r;
      save();
    }

    function ensureCurrentJournalDraft() {
      const j = getCurrentJournal();
      if (j) return j;
      const newJ = { id: uid("j"), createdAt: Date.now(), includeIds: [], roundCount: 0, courtCount: 1, durationSec: 0, schedule: [], currentRoundIndex: 0 };
      db.journals.push(newJ);
      db.currentJournalId = newJ.id;
      return newJ;
    }

    /***********************************************************************
     * ‚úÖ NUEVA JORNADA
     *
     * Antes reutiliz√°bamos siempre la jornada "activa". Ahora:
     * - Si ya hay una jornada con rondas planificadas (o finalizada),
     *   al pulsar "Generar jornada" creamos una NUEVA jornada.
     * - As√≠, las parejas pueden repetirse entre jornadas diferentes.
     ***********************************************************************/
    function createNewJournalDraft() {
      const newJ = {
        id: uid("j"),
        createdAt: Date.now(),
        includeIds: [],
        roundCount: 0,
        courtCount: 1,
        durationSec: 0,
        schedule: [],
        currentRoundIndex: 0
      };
      db.journals.push(newJ);
      db.currentJournalId = newJ.id;
      return newJ;
    }


    function getCurrentJournal() {
      if (!db.currentJournalId) return null;
      return db.journals.find(j => j.id === db.currentJournalId) || null;
    }

    function activateJournal(id) { db.currentJournalId = id; save(); setTab("match"); }

    function deleteJournal(id) {
      if (!confirm("¬øBorrar esta jornada?")) return;
      db.journals = db.journals.filter(j => j.id !== id);
      if (db.currentJournalId === id) db.currentJournalId = db.journals[0]?.id || null;
      save();
    }

    function planMessage(kind, text) {
      const el = $("#planMsg");
      el.classList.remove("hidden");
      el.classList.remove("bg-rose-50","border-rose-200","text-rose-800","bg-emerald-50","border-emerald-200","text-emerald-800","bg-slate-50","border-slate-200","text-slate-800");
      if (kind === "error") el.classList.add("bg-rose-50","border-rose-200","text-rose-800");
      else if (kind === "ok") el.classList.add("bg-emerald-50","border-emerald-200","text-emerald-800");
      else el.classList.add("bg-slate-50","border-slate-200","text-slate-800");
      el.textContent = text;
    }
    function clearPlanMessage() { const el = $("#planMsg"); el.classList.add("hidden"); el.textContent = ""; }

    function buildSchedule() {
      clearPlanMessage();
      if (db.players.length < 4) return planMessage("error","Necesitas al menos 4 jugadoras.");

      const courtCount = Number($("#courtCount").value || 0);
      const includeCount = Number($("#includeCount").value || 0);
      const roundCount = Number($("#matchCount").value || 0);

      if (courtCount < 1) return planMessage("error","Pistas disponibles: m√≠nimo 1.");
      if (roundCount < 1) return planMessage("error","Rondas: m√≠nimo 1.");

      const neededPerRound = 4 * courtCount;
      if (includeCount < neededPerRound) return planMessage("error", `Con ${courtCount} pistas necesitas al menos ${neededPerRound} jugadoras (4√ópistas).`);

      const totalMin = Number($("#totalDurationMin").value || 90);
      const durationSec = Math.floor((totalMin * 60) / roundCount);
      $("#matchDurationLabel").textContent = fmtMMSS(durationSec);

      let j = getCurrentJournal();
      // Si la jornada actual ya tiene rondas (por ejemplo, ya se jug√≥), creamos una NUEVA jornada.
      if (j && (j.schedule?.length || 0) > 0) {
        j = createNewJournalDraft();
      } else {
        j = ensureCurrentJournalDraft();
      }
      j.roundCount = roundCount;
      j.courtCount = courtCount;
      j.durationSec = durationSec;
      j.currentRoundIndex = 0;

      const selectedSet = new Set(j.includeIds || []);
      const allIds = db.players.map(p => p.id);

      if (selectedSet.size < includeCount) {
        const remaining = allIds.filter(id => !selectedSet.has(id));
        shuffleInPlace(remaining);
        while (selectedSet.size < includeCount && remaining.length) selectedSet.add(remaining.pop());
      }

      if (selectedSet.size > includeCount) {
        const arr = Array.from(selectedSet);
        shuffleInPlace(arr);
        j.includeIds = arr.slice(0, includeCount);
      } else {
        j.includeIds = Array.from(selectedSet);
      }

      const res = generateRoundsNoRepeat(j.includeIds, roundCount, courtCount);
      if (!res.ok) {
        planMessage("error", res.message);
        j.schedule = [];
        save();
        return;
      }

      j.schedule = res.schedule;
      planMessage("ok","Jornada generada. Ve a 'Partido' para empezar.");
      save();
      setTimerSeconds(durationSec);
      setTab("match");
    }

    function clearSchedule() {
      const j = getCurrentJournal();
      if (!j) return;
      j.schedule = [];
      j.currentRoundIndex = 0;
      save();
    }

    function generateRoundsNoRepeat(includeIds, roundCount, courtCount) {
      // üîÅ REGLA ACTUALIZADA: en jornadas DIFERENTES s√≠ se pueden repetir parejas.
      // Por eso, aqu√≠ NO usamos el hist√≥rico global (db.pairHistory) como restricci√≥n.
      // Solo evitamos repetir parejas dentro de ESTA jornada.
      const usedGlobal = new Set();
      const usedThisJournal = new Set();
const includedPlayers = includeIds.map(getPlayer).filter(Boolean);

      if (includedPlayers.length < 4 * courtCount) {
        return { ok:false, message:"No hay suficientes jugadoras v√°lidas para las pistas indicadas." };
      }

      const schedule = [];
      for (let r = 0; r < roundCount; r++) {
        const round = findOneRound(includedPlayers, courtCount, usedGlobal, usedThisJournal);
        if (!round) return { ok:false, message:"No se pudo generar sin repetir parejas. Prueba menos rondas, m√°s jugadoras o m√°s comodines." };

        schedule.push(round);

        for (const c of round.courts) {
          usedThisJournal.add(pairKey(c.pairA.leftId, c.pairA.rightId));
          usedThisJournal.add(pairKey(c.pairB.leftId, c.pairB.rightId));
        }
      }
      return { ok:true, schedule };
    }

    function findOneRound(playersPool, courtCount, usedGlobal, usedThisJournal) {
      const ATTEMPTS = 2500;
      const pairsNeeded = 2 * courtCount;
      const playersNeeded = 4 * courtCount;

      for (let t = 0; t < ATTEMPTS; t++) {
        const ids = playersPool.map(p => p.id);
        shuffleInPlace(ids);
        const selected = ids.slice(0, playersNeeded);
        if (selected.length < playersNeeded) continue;

        const remaining = selected.slice();
        const pairs = [];
        const usedRoundPairs = new Set();

        let ok = true;
        for (let k = 0; k < pairsNeeded; k++) {
          const pair = pickOnePair(remaining, usedGlobal, usedThisJournal, usedRoundPairs);
          if (!pair) { ok = false; break; }
          pairs.push(pair);
        }
        if (!ok) continue;

        shuffleInPlace(pairs);
        const courts = [];
        for (let c = 0; c < courtCount; c++) {
          const pA = pairs[2*c], pB = pairs[2*c+1];
          if (!pA || !pB) { ok = false; break; }
          courts.push({ courtNo: c+1, pairA: pA, pairB: pB });
        }
        if (!ok) continue;

        return { id: uid("round"), courts, resultSaved: false };
      }
      return null;
    }

    function pickOnePair(remainingIds, usedGlobal, usedThisJournal, usedRoundPairs) {
      const TRY = 200;
      for (let t = 0; t < TRY; t++) {
        if (remainingIds.length < 2) return null;
        const i = Math.floor(Math.random() * remainingIds.length);
        let j = Math.floor(Math.random() * remainingIds.length);
        while (j === i && remainingIds.length > 1) j = Math.floor(Math.random() * remainingIds.length);

        const idA = remainingIds[i], idB = remainingIds[j];
        const oriented = orientAsLeftRight(idA, idB);
        if (!oriented) continue;

        const k = pairKey(oriented.leftId, oriented.rightId);
        if (usedGlobal.has(k) || usedThisJournal.has(k) || usedRoundPairs.has(k)) continue;

        const toRemove = new Set([idA, idB]);
        for (let idx = remainingIds.length - 1; idx >= 0; idx--) if (toRemove.has(remainingIds[idx])) remainingIds.splice(idx, 1);

        usedRoundPairs.add(k);
        return oriented;
      }
      return null;
    }

    function orientAsLeftRight(idA, idB) {
      const A = getPlayer(idA), B = getPlayer(idB);
      if (!A || !B) return null;
      const A_canL = (A.role === "L" || A.role === "C");
      const A_canR = (A.role === "R" || A.role === "C");
      const B_canL = (B.role === "L" || B.role === "C");
      const B_canR = (B.role === "R" || B.role === "C");
      if (A_canL && B_canR) return { leftId: idA, rightId: idB };
      if (B_canL && A_canR) return { leftId: idB, rightId: idA };
      return null;
    }

    // ===== Timer =====
    // -------------------- Temporizador (robusto: basado en timestamps) --------------------
let timerRemaining = 0;          // segundos (√∫ltimo valor calculado cuando est√° pausado)
let timerEndAt = null;           // timestamp ms cuando est√° corriendo
let timerInterval = null;        // intervalo de refresco UI

function getTimerStore() {
  const j = getCurrentJournal();
  if (!j) return null;
  if (!j.timer) j.timer = { running: false, endAt: null, remaining: 0 };
  return j.timer;
}

function persistTimer() {
  const store = getTimerStore();
  if (!store) return;
  store.running = Boolean(timerEndAt);
  store.endAt = timerEndAt;
  store.remaining = timerRemaining;
  save();
}

function calcRemaining() {
  if (timerEndAt) {
    const sec = Math.ceil((timerEndAt - Date.now()) / 1000);
    return Math.max(0, sec);
  }
  return Math.max(0, Math.floor(timerRemaining));
}

function setTimerSeconds(sec) {
  timerRemaining = Math.max(0, Math.floor(sec));
  $("#timerLabel").textContent = fmtMMSS(timerRemaining);
  persistTimer();
}

function ensureTimerInterval() {
  if (timerInterval) return;
  timerInterval = setInterval(() => {
    const rem = calcRemaining();
    timerRemaining = rem;
    $("#timerLabel").textContent = fmtMMSS(rem);

    if (timerEndAt && rem <= 0) {
      stopTimer();
      onTimerFinished();
    }
  }, 250);
}

function startTimer() {
  const j = getCurrentJournal();
  if (!j || !j.schedule?.length) return showMatchMessage("error","No hay jornada activa.");

  // Si ya est√° corriendo, no reiniciamos.
  if (timerEndAt) return;

  if (timerRemaining <= 0) setTimerSeconds(j.durationSec || 0);
  timerEndAt = Date.now() + (timerRemaining * 1000);
  ensureTimerInterval();
  persistTimer();
  showMatchMessage("ok","Temporizador iniciado.");
}

function stopTimer() {
  // Congela el valor actual y borra el endAt (pausa)
  if (timerEndAt) {
    timerRemaining = calcRemaining();
    timerEndAt = null;
    persistTimer();
  }
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function pauseTimer() { stopTimer(); showMatchMessage("info","Temporizador pausado."); }

function resetTimer() {
  const j = getCurrentJournal();
  stopTimer();
  timerEndAt = null;
  setTimerSeconds(j?.durationSec || 0);
  showMatchMessage("info","Temporizador reiniciado.");
}

// Finaliza la ronda manualmente (por ejemplo, si termin√°is antes) y desbloquea resultados.
function finishRoundEarly() {
  stopTimer();
  timerEndAt = null;
  setTimerSeconds(0);
  onTimerFinished();
}

// Si vuelves a la app tras estar en segundo plano, recalculamos la UI.
document.addEventListener("visibilitychange", () => {
  const rem = calcRemaining();
  timerRemaining = rem;
  $("#timerLabel").textContent = fmtMMSS(rem);
  if (timerEndAt) ensureTimerInterval();
});

function restoreTimerFromStorage() {
  const store = getTimerStore();
  const j = getCurrentJournal();
  if (!store || !j) return;

  // Si cambia la ronda, reiniciamos el timer (evita arrastrar un timer de otra ronda).
  const roundKey = `r${j.currentRoundIndex || 0}`;
  if (store.roundKey && store.roundKey !== roundKey) {
    store.running = false;
    store.endAt = null;
    store.remaining = j.durationSec || 0;
  }
  store.roundKey = roundKey;

  timerEndAt = store.running && store.endAt ? store.endAt : null;
  timerRemaining = (typeof store.remaining === "number") ? store.remaining : (j.durationSec || 0);

  const rem = calcRemaining();
  timerRemaining = rem;
  $("#timerLabel").textContent = fmtMMSS(rem);

  if (timerEndAt && rem > 0) ensureTimerInterval();
  if (timerEndAt && rem <= 0) { stopTimer(); onTimerFinished(); }
}

function onTimerFinished() {
  playBeep();
  showMatchMessage("ok","Tiempo finalizado. Ya puedes introducir resultados.");
  disableResultsUI(false);
}

    function disableResultsUI(disabled) {
      $$(".pairPointsInput").forEach(inp => inp.disabled = disabled);
      $$(".pairGamesInput").forEach(inp => inp.disabled = disabled);
      $("#btnSaveResult").disabled = disabled;
      if (disabled) $("#btnNextMatch").disabled = true;
    }

    function showMatchMessage(kind, text) {
      const el = $("#matchMsg");
      el.classList.remove("hidden");
      el.classList.remove("bg-rose-50","border-rose-200","text-rose-800","bg-emerald-50","border-emerald-200","text-emerald-800","bg-slate-50","border-slate-200","text-slate-800");
      if (kind === "error") el.classList.add("bg-rose-50","border-rose-200","text-rose-800");
      else if (kind === "ok") el.classList.add("bg-emerald-50","border-emerald-200","text-emerald-800");
      else el.classList.add("bg-slate-50","border-slate-200","text-slate-800");
      el.textContent = text;
    }
    function clearMatchMessage() { const el = $("#matchMsg"); el.classList.add("hidden"); el.textContent = ""; }

    function saveResultForCurrentRound() {
      const j = getCurrentJournal();
      if (!j || !j.schedule?.length) return;
      const idx = j.currentRoundIndex || 0;
      const round = j.schedule[idx];
      if (!round) return;

      if (round.resultSaved) {
        showMatchMessage("info","Esta ronda ya est√° guardada.");
        $("#btnNextMatch").disabled = false;
        return;
      }

      const date = $("#resultDate").value;
      if (!date) return showMatchMessage("error","Introduce la fecha.");

      const mode = getScoreMode();
      const showGames = (mode === "games" || mode === "both");
      const showPoints = (mode === "points" || mode === "both");

      const courts = new Map(); // courtNo -> {A:{playerIds,games,points}, B:{...}}
      let totalPairs = 0;

      $$(".pairCard").forEach(card => {
        const courtNo = Number(card.dataset.court || 0);
        const team = card.dataset.team || "";
        const ids = (card.dataset.players || "").split(",").map(x=>x.trim()).filter(Boolean);
        if (!courtNo || (team !== "A" && team !== "B") || ids.length !== 2) return;

        const g = Number(card.querySelector(".pairGamesInput")?.value || 0);
        const p = Number(card.querySelector(".pairPointsInput")?.value || 0);

        if ((showGames && (!Number.isFinite(g) || g < 0)) || (showPoints && (!Number.isFinite(p) || p < 0))) return;

        const entry = courts.get(courtNo) || { A:null, B:null };
        entry[team] = { playerIds: ids, games: showGames ? g : 0, points: showPoints ? p : 0 };
        courts.set(courtNo, entry);
        totalPairs++;
      });

      const expectedPairs = 2 * (j.courtCount || 1);
      if (totalPairs < expectedPairs) return showMatchMessage("error","Faltan marcadores en alguna pareja.");

      // Guardamos resultado por pista y actualizamos puntosTotal (solo si se usan puntos)
      const resultCourts = [];
      const pointsByPlayer = new Map();
      const gamesByPlayer = new Map();

      for (const [courtNo, entry] of courts.entries()) {
        if (!entry.A || !entry.B) return showMatchMessage("error",`Falta marcador en pista ${courtNo}.`);

        const gA = Number(entry.A.games || 0), gB = Number(entry.B.games || 0);
        const pA = Number(entry.A.points || 0), pB = Number(entry.B.points || 0);

        // Repartimos marcadores a jugadoras (para export/import y stats)
        for (const pid of entry.A.playerIds) {
          gamesByPlayer.set(pid, (gamesByPlayer.get(pid) || 0) + gA);
          pointsByPlayer.set(pid, (pointsByPlayer.get(pid) || 0) + pA);
        }
        for (const pid of entry.B.playerIds) {
          gamesByPlayer.set(pid, (gamesByPlayer.get(pid) || 0) + gB);
          pointsByPlayer.set(pid, (pointsByPlayer.get(pid) || 0) + pB);
        }

        resultCourts.push({
          courtNo,
          teamA: { playerIds: entry.A.playerIds, games: gA, points: pA },
          teamB: { playerIds: entry.B.playerIds, games: gB, points: pB },
        });
      }

      // Actualizamos puntosTotal solo si el modo incluye puntos (para que la tabla de Jugadoras siga mostrando algo)
      if (showPoints) {
        for (const [pid, pts] of pointsByPlayer.entries()) {
          const p = getPlayer(pid);
          if (p) p.pointsTotal = (p.pointsTotal || 0) + pts;
        }
      }

      round.resultSaved = true;
      round.result = {
        date,
        comment: ($("#resultComment").value || "").trim(),
        mode,
        points: Object.fromEntries(pointsByPlayer.entries()),
        games: Object.fromEntries(gamesByPlayer.entries()),
        courts: resultCourts
      };

      // Historial de parejas (para evitar repetici√≥n)
      for (const c of round.courts) {
        const k1 = pairKey(c.pairA.leftId, c.pairA.rightId);
        const k2 = pairKey(c.pairB.leftId, c.pairB.rightId);
        if (!db.pairHistory.includes(k1)) db.pairHistory.push(k1);
        if (!db.pairHistory.includes(k2)) db.pairHistory.push(k2);
      }

      showMatchMessage("ok","Resultado guardado. Pasando a la siguiente ronda...");
      disableResultsUI(true);
      $("#resultComment").value = "";
      save();

      setTimeout(() => { goNextRound(); }, 400);
    }

    function goNextRound() {
  const j = getCurrentJournal();
  if (!j || !j.schedule?.length) return;

  // Paramos y reseteamos el timer de la ronda actual
  stopTimer();

  const idx = j.currentRoundIndex || 0;
  if (idx + 1 >= j.schedule.length) {
    showMatchMessage("ok","Jornada finalizada. Mira el ranking.");
    setTab("ranking");
    save();
    return;
  }

  j.currentRoundIndex = idx + 1;

  // Nuevo timer para la nueva ronda
  timerEndAt = null;
  setTimerSeconds(j.durationSec || 0);
  disableResultsUI(true);
  save();

  startTimer();
}

    function countMatchesForPlayer(playerId) {
      let count = 0;
      for (const j of db.journals) {
        for (const r of (j.schedule || [])) {
          if (!r.resultSaved) continue;
          for (const c of (r.courts || [])) {
            const ids = [c.pairA.leftId, c.pairA.rightId, c.pairB.leftId, c.pairB.rightId];
            if (ids.includes(playerId)) count++;
          }
        }
      }
      return count;
    }

    function bulkImport() {
      const raw = $("#bulkImport").value || "";
      const lines = raw.split(/\r?\n/).map(x => x.trim()).filter(Boolean);
      if (!lines.length) return;
      let added = 0;
      for (const line of lines) {
        const parts = line.split(",").map(x => x.trim());
        if (parts.length < 2) continue;
        const [name, roleStr] = parts;
        const role = (roleStr || "").toUpperCase();
        if (!["L","R","C"].includes(role)) continue;
        db.players.push({ id: uid("p"), name: name || "SinNombre", role, pointsTotal: 0 });
        added++;
      }
      alert(`Importadas ${added} jugadoras.`);
      save();
    }

    function exportData() {
      const json = JSON.stringify(db, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "padel-jornada-datos.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }


    /***********************************************************************
     * üìÑ EXPORTAR A EXCEL (CSV)
     *
     * Excel y Google Sheets abren archivos CSV sin problema.
     * Creamos 3 "hojas" en un √∫nico CSV, separadas por t√≠tulos y l√≠neas vac√≠as:
     *  - Ranking (todas las jugadoras)
     *  - Jornadas (resumen)
     *  - Resultados por ronda/pista (detalle)
     ***********************************************************************/
    function csvEscape(value) {
      // Convertimos a texto y escapamos comillas dobles para CSV.
      const s = String(value ?? "");
      // Si contiene comas, saltos de l√≠nea o comillas, lo envolvemos con comillas.
      if (/[",\n\r]/.test(s)) return `"${s.replaceAll('"','""')}"`;
      return s;
    }

    function downloadTextFile(filename, content, mime="text/plain;charset=utf-8") {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function exportCSV() {
      // Usamos ; como separador (com√∫n en Excel en locales ES).
      const SEP = ";";
      const lines = [];

      // ---- Hoja 1: Ranking ----
      lines.push("RANKING");
      lines.push(["Posici√≥n","Jugadora","Rol","Puntos","Partidos jugados"].map(csvEscape).join(SEP));

      const ranked = db.players.slice().sort((a,b)=>(b.pointsTotal||0)-(a.pointsTotal||0));
      ranked.forEach((p, idx) => {
        lines.push([
          idx+1,
          p.name,
          roleLabel(p.role),
          p.pointsTotal || 0,
          countMatchesForPlayer(p.id)
        ].map(csvEscape).join(SEP));
      });

      lines.push(""); // l√≠nea vac√≠a

      // ---- Hoja 2: Jornadas (resumen) ----
      lines.push("JORNADAS (RESUMEN)");
      lines.push(["JornadaId","Creada","Pistas","JugadorasIncluidas","Rondas","RondasCompletadas","Duraci√≥nPorRonda"].map(csvEscape).join(SEP));

      const journalsSorted = db.journals.slice().sort((a,b)=>a.createdAt-b.createdAt);
      journalsSorted.forEach(j => {
        const total = j.schedule?.length || 0;
        const done = j.schedule?.filter(r => r.resultSaved).length || 0;
        lines.push([
          j.id,
          new Date(j.createdAt).toLocaleString("es-ES"),
          j.courtCount || 1,
          (j.includeIds?.length || 0),
          total,
          done,
          fmtMMSS(j.durationSec || 0)
        ].map(csvEscape).join(SEP));
      });

      lines.push("");

      // ---- Hoja 3: Detalle de resultados ----
      lines.push("RESULTADOS (DETALLE)");
      lines.push([
        "JornadaId","FechaJornada","RondaN","Pista","Pareja",
        "JugadoraI","JugadoraD","PuntosPareja",
        "Comentario"
      ].map(csvEscape).join(SEP));

      journalsSorted.forEach(j => {
        const created = new Date(j.createdAt).toLocaleString("es-ES");
        (j.schedule || []).forEach((round, roundIdx) => {
          if (!round.resultSaved || !round.result) return;

          // round.result.points es por jugadora (ya distribuido). Para CSV queremos por pareja.
          // Como ahora pedimos puntos por pareja, reconstruimos los puntos de pareja sumando (idI + idD)/2,
          // pero ojo: son iguales para ambos. Aqu√≠ lo calculamos leyendo el mapa y cogiendo el valor de uno.
          const pointsMap = round.result.points || {};
          const comment = round.result.comment || "";

          (round.courts || []).forEach(c => {
            const aL = getPlayer(c.pairA.leftId), aR = getPlayer(c.pairA.rightId);
            const bL = getPlayer(c.pairB.leftId), bR = getPlayer(c.pairB.rightId);

            // Pareja A
            const ptsA = Number(pointsMap[c.pairA.leftId] || 0); // mismo que rightId
            lines.push([
              j.id, created, (roundIdx+1), c.courtNo, "A",
              aL?.name||"", aR?.name||"", ptsA,
              comment
            ].map(csvEscape).join(SEP));

            // Pareja B
            const ptsB = Number(pointsMap[c.pairB.leftId] || 0);
            lines.push([
              j.id, created, (roundIdx+1), c.courtNo, "B",
              bL?.name||"", bR?.name||"", ptsB,
              comment
            ].map(csvEscape).join(SEP));
          });
        });
      });

      const stamp = new Date().toISOString().slice(0,19).replaceAll(":","-");
      downloadTextFile(`padel_export_${stamp}.csv`, lines.join("\n"), "text/csv;charset=utf-8");
    }

    function resetAll() {
      if (!confirm("Esto borrar√° TODO. ¬øSeguro?")) return;
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }

    function bindEvents() {
      $$(".tab").forEach(btn => btn.addEventListener("click", () => setTab(btn.dataset.tab)));
      $$(".stats-tab").forEach(btn => btn.addEventListener("click", () => { setStatsSub(btn.dataset.stats); if (btn.dataset.stats === "veteranas") renderStatsTab(); }));

      // Sugerencia autom√°tica de rondas
      $("#btnApplySuggestedRounds")?.addEventListener("click", applySuggestedRounds);
      ["courtsCount","includeCount","totalDurationMin","matchCount"].forEach(id=>{
        const el = $("#"+id);
        if (el) el.addEventListener("input", () => { renderSuggestedRounds(); renderMatchDurationPreview(); });
      });

      // Tipo de marcador (Juegos / Puntos / Ambos)
      $$('input[name="scoreMode"]').forEach(r => r.addEventListener("change", () => {
        setScoreMode(getScoreMode());
        updateScoreModeUI();
      }));


      $("#btnAddPlayer").addEventListener("click", addPlayer);
      $("#btnBulkImport").addEventListener("click", bulkImport);
      $("#btnBulkClear").addEventListener("click", () => $("#bulkImport").value = "");

      // ‚úÖ Botones: seleccionar/deseleccionar todas las jugadoras (pesta√±a "Jornada")
      // - "Seleccionar todas": marca todas las jugadoras disponibles en la jornada
      // - "Quitar selecci√≥n": deja la selecci√≥n vac√≠a
      $("#btnSelectAllPlayers").addEventListener("click", () => {
        const j = ensureCurrentJournalDraft();
        j.includeIds = db.players.map(p => p.id);
        save(); // guarda y repinta (ver√°s todos los checks marcados)
      });

      $("#btnClearSelectedPlayers").addEventListener("click", () => {
        const j = ensureCurrentJournalDraft();
        j.includeIds = [];
        save(); // guarda y repinta (ver√°s todos los checks desmarcados)
      });


      $("#matchCount").addEventListener("input", renderPlanDerived);
      $("#courtCount").addEventListener("input", renderPlanDerived);

      $("#btnBuildSchedule").addEventListener("click", buildSchedule);
      $("#btnClearSchedule").addEventListener("click", clearSchedule);

      $("#btnStart").addEventListener("click", startTimer);
      $("#btnPause").addEventListener("click", pauseTimer);
      $("#btnResetTimer").addEventListener("click", resetTimer);
      $("#btnFinishRound").addEventListener("click", finishRoundEarly);

      $("#btnSaveResult").addEventListener("click", saveResultForCurrentRound);
      $("#btnNextMatch").addEventListener("click", goNextRound);

      $("#btnGoRanking").addEventListener("click", () => setTab("ranking"));
      $("#btnRecalcRanking").addEventListener("click", () => renderRanking());

      $("#btnExport").addEventListener("click", exportData);
      $("#btnExportCSV").addEventListener("click", exportCSV);
      $("#btnReset").addEventListener("click", resetAll);

      // ‚úÖ Cerrar panel de detalle de jornada
      $("#btnClearJournalDetail").addEventListener("click", () => {
        selectedJournalId = null;
        renderJournalDetail();
      });
    }

    function initDefaults() {
      if (!$("#courtCount").value) $("#courtCount").value = "1";
      if (!$("#includeCount").value) $("#includeCount").value = "8";
      if (!$("#matchCount").value) $("#matchCount").value = "6";
      renderPlanDerived();
      if (!$("#resultDate").value) $("#resultDate").value = new Date().toISOString().slice(0,10);
    }

    function init() {
      load();
      bindEvents();
      initDefaults();
      setTab("setup");
      renderAll();

      const j = getCurrentJournal();
      setTimerSeconds(j?.durationSec || 0);
    }

    init();
  


/***********************************************************************
 * üì≤ PWA: instalaci√≥n + Service Worker
 ***********************************************************************/
let deferredInstallPrompt = null;

window.addEventListener("beforeinstallprompt", (e) => {
  // Android/Chrome: capturamos el evento para mostrar nuestro propio bot√≥n
  e.preventDefault();
  deferredInstallPrompt = e;
  const b = document.getElementById("btnInstall");
  if (b) b.classList.remove("hidden");
});

document.getElementById("btnInstall")?.addEventListener("click", async () => {
  if (!deferredInstallPrompt) return;
  deferredInstallPrompt.prompt();
  try { await deferredInstallPrompt.userChoice; } catch (e) {}
  deferredInstallPrompt = null;
  document.getElementById("btnInstall")?.classList.add("hidden");
});

// iOS no lanza beforeinstallprompt. Aqu√≠ podr√≠as mostrar un aviso,
// pero para ‚Äúmodo dummies‚Äù lo dejamos como instrucci√≥n en el README.

if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("./service-worker.js").catch(console.warn);
  });
}

/***********************************************************************
 * üì• IMPORTAR (JSON) ‚Äî mismo formato que Exportar
 ***********************************************************************/
function isValidDbShape(obj) {
  if (!obj || typeof obj !== "object") return false;
  // Permitimos que falten algunas claves, pero al menos deben existir players y journals.
  if (!Array.isArray(obj.players)) return false;
  if (!Array.isArray(obj.journals)) return false;
  return true;
}

function normalizeImportedDb(obj) {
  // Mantiene la estructura m√≠nima y a√±ade defaults por si faltan campos.
  const vetsPlayers = Array.isArray(obj.veteranasPlayers) ? obj.veteranasPlayers : [];
  const vetsPlayersNorm = vetsPlayers.map(p => ({
    id: p.id ?? (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random()),
    name: p.name ?? "",
    side: p.side ?? "J",
    age: (p.age === null || p.age === undefined || p.age === "") ? null : Number(p.age),
    selected: (p.selected === undefined) ? true : !!p.selected
  }));

  return {
    players: Array.isArray(obj.players) ? obj.players : [],
    pairHistory: Array.isArray(obj.pairHistory) ? obj.pairHistory : [],
    journals: Array.isArray(obj.journals) ? obj.journals : [],
    currentJournalId: obj.currentJournalId ?? null,
    veteranasPlayers: vetsPlayersNorm,
    veteranasPairs: Array.isArray(obj.veteranasPairs) ? obj.veteranasPairs : [],
    veteranasSeen: Array.isArray(obj.veteranasSeen) ? obj.veteranasSeen : [],
    veteranasMeta: obj.veteranasMeta ?? { noMore: false, lastMsg: "" }
  };
}

async function importDataFromFile(file) {
  const text = await file.text();
  let parsed;
  try {
    parsed = JSON.parse(text);
  } catch (e) {
    alert("El archivo no es un JSON v√°lido.");
    return;
  }
  if (!isValidDbShape(parsed)) {
    alert("El JSON no tiene el formato esperado (players/journals).");
    return;
  }
  // Confirmaci√≥n simple para evitar sobrescribir sin querer.
  const ok = confirm("Esto reemplazar√° tus datos actuales por los del archivo. ¬øContinuar?");
  if (!ok) return;

  db = { ...db, ...normalizeImportedDb(parsed) };
  save();
  alert("Importaci√≥n completada ‚úÖ");
}

document.getElementById("btnImport")?.addEventListener("click", () => {
  document.getElementById("fileImport")?.click();
});

document.getElementById("fileImport")?.addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  await importDataFromFile(file);
  // Permite volver a importar el mismo archivo si hace falta
  e.target.value = "";
});

/***********************************************************************
 * TAB: VETERANAS (5 parejas por umbrales de edad + posiciones)
 **********************************************************************/
const VET_THRESHOLDS = [75, 80, 85, 90, 95];

function sideLabel(s) {
  return s === "L" ? "Izquierda" : (s === "R" ? "Derecha" : "Comod√≠n");
}

function getVetsPlayers() {
  return Array.isArray(db.veteranasPlayers) ? db.veteranasPlayers : (db.veteranasPlayers = []);
}

function addVetsPlayer() {
  const name = ($("#vName").value || "").trim();
  const side = $("#vSide").value;
  const ageRaw = ($("#vAge").value || "").trim();
  const age = ageRaw === "" ? null : Number(ageRaw);

  if (!name) { alert("Introduce un nombre."); return; }
  if (ageRaw !== "" && (!Number.isFinite(age) || age <= 0)) { alert("Edad no v√°lida."); return; }

  const p = { id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random(), name, side, age, selected: true };
  getVetsPlayers().push(p);
  db.veteranasPairs = [];
  db.veteranasSeen = [];
  if (db.veteranasMeta) { db.veteranasMeta.noMore = false; db.veteranasMeta.lastMsg = ""; }
  // Limpia inputs
  $("#vName").value = "";
  $("#vAge").value = "";
  save();
}

function deleteVetsPlayer(id) {
  db.veteranasPlayers = getVetsPlayers().filter(p => p.id !== id);
  db.veteranasPairs = [];
  db.veteranasSeen = [];
  if (db.veteranasMeta) { db.veteranasMeta.noMore = false; db.veteranasMeta.lastMsg = ""; }
  save();
}



function editVetsPlayerPrompt(id) {
  const p = getVetsPlayers().find(x => x.id === id);
  if (!p) return;

  // Nombre (no obligatorio cambiarlo, pero lo permitimos)
  const name = prompt("Nombre:", p.name);
  if (name === null) return;

  const sideInput = prompt("Posici√≥n (I=Izquierda, D=Derecha, C=Comod√≠n):", (p.side === "L" ? "I" : p.side === "R" ? "D" : "C"));
  if (sideInput === null) return;
  const s = sideInput.trim().toUpperCase();
  let side = p.side;
  if (["I","IZQ","IZQUIERDA","L"].includes(s)) side = "L";
  else if (["D","DER","DERECHA","R"].includes(s)) side = "R";
  else if (["C","COMODIN","COMOD√çN","J"].includes(s)) side = "J";
  else return alert("Posici√≥n inv√°lida. Usa I, D o C.");

  const ageInput = prompt("Edad (deja vac√≠o si no quieres poner edad):", (Number.isFinite(p.age) ? String(p.age) : ""));
  if (ageInput === null) return;
  let age = null;
  const t = ageInput.trim();
  if (t !== "") {
    const n = Number(t);
    if (!Number.isFinite(n) || n < 1 || n > 120) return alert("Edad inv√°lida.");
    age = Math.floor(n);
  }

  // Actualiza
  p.name = name.trim() || p.name;
  p.side = side;
  p.age = age;

  // Si se queda sin edad, no es elegible para Veteranas
  if (!Number.isFinite(p.age)) {
    p.selected = false;
  }

  // Si la jugadora estaba usada en parejas/slots, limpiamos para evitar inconsistencias.
  const usedInAuto = Array.isArray(db.veteranasPairs) && db.veteranasPairs.some(pair => pair && pair.players && pair.players.some(pl => pl && pl.id === id));
  const usedInManual = db.veteranasManual && db.veteranasManual.slots && db.veteranasManual.slots.some(slt => slt && (slt.L === id || slt.R === id));
  if (usedInAuto) {
    db.veteranasPairs = [];
  }
  if (usedInManual) {
    db.veteranasManual.slots = initVeteranasManualSlots().map((slot, i) => {
      const cur = db.veteranasManual.slots[i] || slot;
      return {
        ...cur,
        L: (cur.L === id ? null : cur.L),
        R: (cur.R === id ? null : cur.R)
      };
    });
  }
  // En cualquier caso, reiniciamos "seen" y mensajes porque cambi√≥ el espacio de b√∫squeda
  db.veteranasSeen = [];
  if (db.veteranasMeta) { db.veteranasMeta.noMore = false; db.veteranasMeta.lastMsg = ""; }

  save();
  if (usedInAuto || usedInManual) {
    // Mensaje suave (no bloqueante)
    setTimeout(() => alert("Cambios guardados. Se han limpiado algunas selecciones/parejas porque la jugadora estaba siendo utilizada."), 0);
  }
}

function clearVetsPlayers() {
  const ok = confirm("¬øBorrar la lista de jugadoras para Veteranas?");
  if (!ok) return;
  db.veteranasPlayers = [];
  db.veteranasPairs = [];
  db.veteranasSeen = [];
  if (db.veteranasMeta) { db.veteranasMeta.noMore = false; db.veteranasMeta.lastMsg = ""; }
  save();
}

function eligibleVetsPlayers() {
  return getVetsPlayers().filter(p => (p.selected !== false) && Number.isFinite(p.age) && p.age !== null);
}

function ensureVeteranasState() {
  if (!db.veteranasMode) db.veteranasMode = "auto";
  if (!db.veteranasManual) db.veteranasManual = { slots: [], pairs: [], msg: "" };
  if (!Array.isArray(db.veteranasManual.slots)) db.veteranasManual.slots = [];
  if (!Array.isArray(db.veteranasPairs)) db.veteranasPairs = [];
  if (!Array.isArray(db.veteranasSeen)) db.veteranasSeen = [];
  if (!db.veteranasMeta) db.veteranasMeta = { noMore: false, lastMsg: "" };
}

function initVeteranasManualSlots() {
  ensureVeteranasState();
  const slots = db.veteranasManual.slots;
  while (slots.length < VET_THRESHOLDS.length) slots.push({ L: null, R: null });
  if (slots.length > VET_THRESHOLDS.length) slots.length = VET_THRESHOLDS.length;
  // Normalizar valores vac√≠os
  for (const s of slots) {
    if (!s.L) s.L = null;
    if (!s.R) s.R = null;
  }
  db.veteranasManual.slots = slots;
  return slots;
}

function canPlayLeft(p) { return p && (p.side === "L" || p.side === "J"); }
function canPlayRight(p) { return p && (p.side === "R" || p.side === "J"); }
function orientedOk(L, R) { return canPlayLeft(L) && canPlayRight(R); }

// Completa SOLO los huecos libres respetando las selecciones manuales.
// Devuelve { ok, slots, reason }
function solveVeteranasFillHoles(players, slotsIn, thresholds = VET_THRESHOLDS) {
  const byId = new Map(players.map(p => [p.id, p]));
  const slots = slotsIn.map(s => ({ L: s.L || null, R: s.R || null }));

  // Validar duplicados en fijos
  const fixedIds = [];
  for (const s of slots) { if (s.L) fixedIds.push(s.L); if (s.R) fixedIds.push(s.R); }
  const dup = fixedIds.find((id, i) => fixedIds.indexOf(id) !== i);
  if (dup) return { ok: false, reason: "Hay una jugadora seleccionada m√°s de una vez en modo manual." };

  // Validar fijos contra reglas/umbrales
  for (let i = 0; i < thresholds.length; i++) {
    const th = thresholds[i];
    const s = slots[i];
    if (s.L && !byId.has(s.L)) return { ok: false, reason: "Selecci√≥n manual inv√°lida (jugadora no disponible/seleccionada)." };
    if (s.R && !byId.has(s.R)) return { ok: false, reason: "Selecci√≥n manual inv√°lida (jugadora no disponible/seleccionada)." };
    if (s.L && s.R) {
      const L = byId.get(s.L), R = byId.get(s.R);
      if (!orientedOk(L, R)) return { ok: false, reason: `La Pareja ${i+1} no cumple Izquierda/Derecha con tus selecciones.` };
      const sum = L.age + R.age;
      if (sum < th) return { ok: false, reason: `La Pareja ${i+1} no cumple el umbral de edad (${sum} < ${th}).` };
    }
  }

  // Orden de resoluci√≥n: umbrales altos primero para facilitar.
  const order = thresholds.map((th, idx) => ({ th, idx })).sort((a, b) => b.th - a.th);

  const used = new Set(fixedIds);

  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function candidatesForMissing(idx, missingSide) {
    const th = thresholds[idx];
    const s = slots[idx];
    const fixedId = (missingSide === "L") ? s.R : s.L;
    const fixed = fixedId ? byId.get(fixedId) : null;

    const pool = players.filter(p => !used.has(p.id));
    const roleOk = (p) => (missingSide === "L" ? canPlayLeft(p) : canPlayRight(p));
    const oriented = (p) => {
      const L = (missingSide === "L") ? p : fixed;
      const R = (missingSide === "L") ? fixed : p;
      return orientedOk(L, R) && ((L.age + R.age) >= th);
    };
    return shuffle(pool.filter(p => roleOk(p) && oriented(p)));
  }

  function candidatesForEmptyPair(idx) {
    const th = thresholds[idx];
    const pool = players.filter(p => !used.has(p.id));
    const lefts = pool.filter(canPlayLeft);
    const rights = pool.filter(canPlayRight);
    const out = [];
    for (const L of lefts) {
      for (const R of rights) {
        if (L.id === R.id) continue;
        if (!orientedOk(L, R)) continue;
        const sum = L.age + R.age;
        if (sum < th) continue;
        out.push({ LId: L.id, RId: R.id, sum });
      }
    }
    // aleatorio + preferir m√≠nimos para conservar edades altas
    out.sort((a,b)=>a.sum-b.sum);
    return shuffle(out).slice(0, Math.min(2000, out.length)); // limit defensivo
  }

  function rec(k) {
    if (k === order.length) return true;
    const { idx } = order[k];
    const s = slots[idx];

    // Ya completo (fijo o completado) -> marcar usados y seguir
    if (s.L && s.R) return rec(k + 1);

    // Solo falta un lado
    if (s.L && !s.R) {
      const fixedL = byId.get(s.L);
      if (!canPlayLeft(fixedL)) return false;
      const th = thresholds[idx];
      const pool = players.filter(p => !used.has(p.id) && (canPlayRight(p)));
      const cands = shuffle(pool.filter(R => orientedOk(fixedL, R) && (fixedL.age + R.age) >= th));
      for (const R of cands) {
        s.R = R.id;
        used.add(R.id);
        if (rec(k + 1)) return true;
        used.delete(R.id);
        s.R = null;
      }
      return false;
    }
    if (!s.L && s.R) {
      const fixedR = byId.get(s.R);
      if (!canPlayRight(fixedR)) return false;
      const th = thresholds[idx];
      const pool = players.filter(p => !used.has(p.id) && (canPlayLeft(p)));
      const cands = shuffle(pool.filter(L => orientedOk(L, fixedR) && (L.age + fixedR.age) >= th));
      for (const L of cands) {
        s.L = L.id;
        used.add(L.id);
        if (rec(k + 1)) return true;
        used.delete(L.id);
        s.L = null;
      }
      return false;
    }

    // Ninguno elegido
    const pairCands = candidatesForEmptyPair(idx);
    for (const cand of pairCands) {
      if (used.has(cand.LId) || used.has(cand.RId)) continue;
      s.L = cand.LId; s.R = cand.RId;
      used.add(cand.LId); used.add(cand.RId);
      if (rec(k + 1)) return true;
      used.delete(cand.LId); used.delete(cand.RId);
      s.L = null; s.R = null;
    }
    return false;
  }

  // Marcar usados fijos (los de slots completos ya est√°n en used, los parciales est√°n incluidos)
  // Para parciales: si s.L o s.R est√° fijo, ya est√° en used.
  const ok = rec(0);
  if (!ok) return { ok: false, reason: "No es posible completar las parejas con la selecci√≥n actual." };
  return { ok: true, slots };
}


function isValidPair(a, b) {
  // Reglas de posiciones: una izquierda y una derecha; comod√≠n vale para ambos.
  const sa = a.side, sb = b.side;
  const isJ = (s) => s === "J";
  const isL = (s) => s === "L";
  const isR = (s) => s === "R";
  // Posibilidades v√°lidas:
  // L+R, L+J, J+R, J+J (asignables a L/R)
  if ((isL(sa) && isR(sb)) || (isR(sa) && isL(sb))) return true;
  if ((isL(sa) && isJ(sb)) || (isJ(sa) && isL(sb))) return true;
  if ((isR(sa) && isJ(sb)) || (isJ(sa) && isR(sb))) return true;
  if (isJ(sa) && isJ(sb)) return true;
  return false;
}

function makePairsFromPlayers(players) {
  const pairs = [];
  for (let i = 0; i < players.length; i++) {
    for (let j = i + 1; j < players.length; j++) {
      const a = players[i], b = players[j];
      if (!isValidPair(a, b)) continue;
      const sum = (a.age || 0) + (b.age || 0);
      pairs.push({ aId: a.id, bId: b.id, sum });
    }
  }
  return pairs;
}

function solutionSignatureFromPairs(pairs) {
  // Firma estable para comparar soluciones: pares ordenados por ids y luego concatenados.
  // Formato: "idA-idB|idC-idD|..."
  const parts = pairs.map(p => {
    const ids = [p.aId, p.bId].sort();
    return ids[0] + "-" + ids[1];
  }).sort();
  return parts.join("|");
}

function shuffleArray(arr) {
  // Fisher‚ÄìYates
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function solveVeteranas(players, thresholds = VET_THRESHOLDS, excludeSigs = new Set()) {
  // Backtracking: asigna 5 parejas sin solape cumpliendo umbrales.
  // Adem√°s: evita repetir soluciones ya vistas (excludeSigs).
  const byId = new Map(players.map(p => [p.id, p]));
  const allPairs = makePairsFromPlayers(players);

  // Candidatos por umbral (buscamos de mayor a menor para garantizar 95 primero, etc.)
  const thDesc = [...thresholds].sort((x, y) => y - x);
  const candidates = new Map();
  for (const th of thDesc) {
    const c = allPairs
      .filter(p => p.sum >= th)
      .sort((p1, p2) => p1.sum - p2.sum); // preferimos m√≠nimos para conservar edades altas
    candidates.set(th, c);
  }

  const used = new Set();
  const chosen = [];

  function rec(k) {
    if (k === thDesc.length) {
      const sig = solutionSignatureFromPairs(chosen);
      if (excludeSigs.has(sig)) return false;
      return true;
    }

    const th = thDesc[k];
    const cands = candidates.get(th);

    // Aleatorizamos un poco para que "Recalcular" proponga alternativas.
    const cands2 = shuffleArray([...cands]);

    for (const pr of cands2) {
      if (used.has(pr.aId) || used.has(pr.bId)) continue;
      used.add(pr.aId); used.add(pr.bId);
      chosen.push({ threshold: th, ...pr });
      if (rec(k + 1)) return true;
      chosen.pop();
      used.delete(pr.aId); used.delete(pr.bId);
    }
    return false;
  }

  const ok = rec(0);
  if (!ok) {
    // Si no encontramos, puede ser porque no hay soluci√≥n en general, o porque ya hemos excluido todas las existentes.
    // Hacemos una comprobaci√≥n r√°pida: ¬øexiste al menos una soluci√≥n SIN excluir?
    const okAny = (function existsAny() {
      const used2 = new Set();
      const chosen2 = [];
      function rec2(k) {
        if (k === thDesc.length) return true;
        const th = thDesc[k];
        const cands = candidates.get(th);
        for (const pr of cands) {
          if (used2.has(pr.aId) || used2.has(pr.bId)) continue;
          used2.add(pr.aId); used2.add(pr.bId);
          chosen2.push(pr);
          if (rec2(k + 1)) return true;
          chosen2.pop();
          used2.delete(pr.aId); used2.delete(pr.bId);
        }
        return false;
      }
      return rec2(0);
    })();

    if (okAny) {
      return { ok: false, pairs: [], noMore: true, reason: "No hay m√°s combinaciones nuevas posibles con la selecci√≥n actual." };
    }
    return { ok: false, pairs: [], noMore: false, reason: "No hay una combinaci√≥n v√°lida con las edades/posiciones actuales." };
  }

  // Convertimos al orden 75..95
  const chosenMap = new Map(chosen.map(x => [x.threshold, x]));
  const ordered = thresholds.map(th => chosenMap.get(th)).filter(Boolean).map(x => ({
    threshold: x.threshold,
    sum: x.sum,
    a: byId.get(x.aId),
    b: byId.get(x.bId),
  }));

  return { ok: true, pairs: ordered, sig: solutionSignatureFromPairs(chosen) };
}

function recalcVeteranasAuto() {
  const players = eligibleVetsPlayers();

  // Reiniciamos estado de mensajes
  if (!db.veteranasMeta) db.veteranasMeta = { noMore: false, lastMsg: "" };
  db.veteranasMeta.noMore = false;
  db.veteranasMeta.lastMsg = "";

  if (players.length < 10) {
    db.veteranasPairs = [];
    db.veteranasSeen = db.veteranasSeen || [];
    save();
    return;
  }

  db.veteranasSeen = Array.isArray(db.veteranasSeen) ? db.veteranasSeen : [];
  const exclude = new Set(db.veteranasSeen);

  // Evitar repetir tambi√©n la soluci√≥n actual (aunque no est√© en seen)
  if (Array.isArray(db.veteranasPairs) && db.veteranasPairs.length) {
    try {
      const currentSig = solutionSignatureFromPairs(db.veteranasPairs.map(p => ({
        aId: p.a?.id || p.aId,
        bId: p.b?.id || p.bId
      })));
      if (currentSig) exclude.add(currentSig);
    } catch (e) {}
  }

  const res = solveVeteranas(players, VET_THRESHOLDS, exclude);

  if (!res.ok) {
    if (res.noMore) {
      db.veteranasMeta.noMore = true;
      db.veteranasMeta.lastMsg = res.reason;
      // mantenemos la soluci√≥n actual si existe; si no, dejamos vac√≠o
    } else {
      db.veteranasPairs = [];
      db.veteranasMeta.lastMsg = res.reason;
    }
    save();
    return;
  }

  db.veteranasPairs = res.pairs;
  if (res.sig) db.veteranasSeen.push(res.sig);
  save();
}

function recalcVeteranasManual() {
  ensureVeteranasState();
  const players = eligibleVetsPlayers();
  const slots = initVeteranasManualSlots();

  if (players.length < 10) {
    db.veteranasManual.msg = `Necesitas al menos 10 jugadoras con edad. Ahora mismo: ${players.length}.`;
    save();
    return;
  }

  const res = solveVeteranasFillHoles(players, slots, VET_THRESHOLDS);
  if (!res.ok) {
    db.veteranasManual.msg = res.reason || "No es posible completar las parejas con la selecci√≥n actual.";
    save();
    return;
  }

  db.veteranasManual.slots = res.slots;
  db.veteranasManual.msg = "";
  save();
}

function recalcVeteranas() {
  ensureVeteranasState();
  const mode = db.veteranasMode || "auto";
  if (mode === "manual") return recalcVeteranasManual();
  return recalcVeteranasAuto();
}


function renderVeteranas() {
  // Safeguard if elements not present yet
  const tbody = document.getElementById("vPlayersTbody");
  if (!tbody) return;

  const list = getVetsPlayers();
  const elig = eligibleVetsPlayers();
  document.getElementById("vEligibleCount").textContent = String(elig.length);

  tbody.innerHTML = list.map(p => {
    const hasAge = Number.isFinite(p.age) && p.age !== null;
    const age = (!hasAge) ? "‚Äî" : String(p.age);
    const badge = (!hasAge) ? '<span class="text-xs px-2 py-1 rounded-full bg-amber-50 text-amber-700 border border-amber-200">Sin edad (no elegible)</span>' : '';
    const checked = (p.selected !== false) && hasAge ? "checked" : "";
    const disabled = hasAge ? "" : "disabled";
    return `
      <tr class="border-b">
        <td class="py-2 pr-3">
          <input type="checkbox" class="h-4 w-4 accent-sky-600" data-vsel="${p.id}" ${checked} ${disabled}/>
        </td>
        <td class="py-2 pr-3 font-medium">${escapeHtml(p.name)}</td>
        <td class="py-2 pr-3">${sideLabel(p.side)}</td>
        <td class="py-2 pr-3">${age} ${badge}</td>
        <td class="py-2 pr-0 text-right">
          <button class="btn-secondary px-3 py-1.5 rounded-lg text-xs font-medium mr-2" data-vedit="${p.id}">Editar</button>
          <button class="btn-danger px-3 py-1.5 rounded-lg text-xs font-medium" data-vdel="${p.id}">Eliminar</button>
        </td>
      </tr>`;
  }).join("");

  // bind delete buttons
  tbody.querySelectorAll("[data-vdel]").forEach(btn => {
    btn.addEventListener("click", () => deleteVetsPlayer(btn.getAttribute("data-vdel")));
  });
  // bind edit buttons
  tbody.querySelectorAll("[data-vedit]").forEach(btn => {
    btn.addEventListener("click", () => editVetsPlayerPrompt(btn.getAttribute("data-vedit")));
  });// bind selection checkboxes
  tbody.querySelectorAll("[data-vsel]").forEach(chk => {
    chk.addEventListener("change", () => {
      const id = chk.getAttribute("data-vsel");
      const listNow = getVetsPlayers();
      const p = listNow.find(x => x.id === id);
      if (!p) return;
      p.selected = chk.checked;
      // Si cambia la selecci√≥n, invalidamos parejas actuales y el historial de soluciones,
      // porque el espacio de b√∫squeda ha cambiado.
      db.veteranasPairs = [];
      db.veteranasSeen = [];
      if (db.veteranasMeta) { db.veteranasMeta.noMore = false; db.veteranasMeta.lastMsg = ""; }
      save();
    });
  });

  // Render pairs (Auto / Manual)
  const wrap = document.getElementById("vPairsWrap");
  const msg = document.getElementById("vPairsMsg");
  wrap.innerHTML = "";

  ensureVeteranasState();

  const mode = db.veteranasMode || "auto";
  // Sync radio UI + bind events
  document.querySelectorAll('input[name="vMode"]').forEach(r => {
    r.checked = (r.value === mode);
    r.onchange = () => {
      db.veteranasMode = r.value;
      // Limpieza de mensajes para no confundir
      if (!db.veteranasMeta) db.veteranasMeta = { noMore: false, lastMsg: "" };
      db.veteranasMeta.noMore = false;
      db.veteranasMeta.lastMsg = "";
      // En manual, no tocamos slots; en auto, no tocamos manual.
      save();
    };
  });

  if (elig.length < 10) {
    msg.innerHTML = `Necesitas al menos <b>10 jugadoras con edad</b> para generar 5 parejas. Ahora mismo: <b>${elig.length}</b>.`;
    return;
  }

  if (mode === "manual") {
    // --- MANUAL MODE ---
    const slots = initVeteranasManualSlots(); // always 5 items
    const byId = new Map(elig.map(p => [p.id, p]));

    // Helper: compute used ids across all slots (excluding optionally one)
    function usedIds(exceptId) {
      const u = new Set();
      slots.forEach(s => {
        if (s.L && s.L !== exceptId) u.add(s.L);
        if (s.R && s.R !== exceptId) u.add(s.R);
      });
      return u;
    }

    function canPlayLeft(p) { return p && (p.side === "L" || p.side === "J"); }
    function canPlayRight(p){ return p && (p.side === "R" || p.side === "J"); }
    function orientedOk(L, R) { return canPlayLeft(L) && canPlayRight(R); }

    function candidatesFor(pairIdx, which) {
      const th = VET_THRESHOLDS[pairIdx];
      const s = slots[pairIdx];
      const current = (which === "L") ? s.L : s.R;
      const otherId = (which === "L") ? s.R : s.L;
      const other = otherId ? byId.get(otherId) : null;

      const used = usedIds(current);
      const pool = elig.filter(p => !used.has(p.id));

      const roleOk = (p) => (which === "L" ? canPlayLeft(p) : canPlayRight(p));
      const partnerRoleOk = (p) => (which === "L" ? canPlayRight(p) : canPlayLeft(p));

      // If other side fixed, only show candidates that make sum>=th with correct orientation
      if (other) {
        return pool.filter(p => {
          if (!roleOk(p)) return false;
          const L = (which === "L") ? p : other;
          const R = (which === "L") ? other : p;
          if (!orientedOk(L, R)) return false;
          return (L.age + R.age) >= th;
        }).sort((a,b)=>a.age-b.age);
      }

      // Other side empty: candidate must be roleOk AND there exists at least one partner remaining that can satisfy threshold.
      return pool.filter(p => {
        if (!roleOk(p)) return false;
        const remaining = pool.filter(x => x.id !== p.id);
        const possiblePartners = remaining.filter(pp => partnerRoleOk(pp));
        for (const pp of possiblePartners) {
          const L = (which === "L") ? p : pp;
          const R = (which === "L") ? pp : p;
          if (!orientedOk(L, R)) continue;
          if ((L.age + R.age) >= th) return true;
        }
        return false;
      }).sort((a,b)=>a.age-b.age);
    }

    function renderSelect(pairIdx, which) {
      const s = slots[pairIdx];
      const selectedId = (which === "L") ? s.L : s.R;
      const cands = candidatesFor(pairIdx, which);

      // If currently selected id is no longer in candidates (e.g. due to used elsewhere), still show it to avoid "jump"
      const selectedPlayer = selectedId ? byId.get(selectedId) : null;
      const options = [];
      options.push(`<option value="">‚Äî</option>`);
      if (selectedPlayer && !cands.some(p=>p.id===selectedId)) {
        options.push(`<option value="${selectedId}">${escapeHtml(selectedPlayer.name)} ¬∑ ${sideLabel(selectedPlayer.side)} ¬∑ ${selectedPlayer.age}</option>`);
      }
      cands.forEach(p => {
        options.push(`<option value="${p.id}">${escapeHtml(p.name)} ¬∑ ${sideLabel(p.side)} ¬∑ ${p.age}</option>`);
      });

      const label = (which === "L") ? "Izquierda / Comod√≠n" : "Derecha / Comod√≠n";
      const selId = `vMan_${pairIdx}_${which}`;
      return `
        <div>
          <label class="text-xs font-medium text-slate-600">${label}</label>
          <select id="${selId}" class="mt-1 w-full border rounded-xl px-3 py-2">
            ${options.join("")}
          </select>
        </div>
      `;
    }

    function pairStatus(pairIdx) {
      const th = VET_THRESHOLDS[pairIdx];
      const s = slots[pairIdx];
      const L = s.L ? byId.get(s.L) : null;
      const R = s.R ? byId.get(s.R) : null;
      if (!L || !R) return { text: "Incompleta", ok: false, sum: null };
      const sum = (L.age + R.age);
      const ok = sum >= th;
      return { text: `${sum} a√±os`, ok, sum };
    }

    // Build UI cards
    wrap.innerHTML = VET_THRESHOLDS.map((th, i) => {
      const st = pairStatus(i);
      const badge = st.sum === null
        ? `<span class="text-xs px-2 py-1 rounded-full bg-slate-100 text-slate-700 border border-slate-200">Pendiente</span>`
        : (st.ok
            ? `<span class="text-xs px-2 py-1 rounded-full bg-emerald-50 text-emerald-700 border border-emerald-200">OK</span>`
            : `<span class="text-xs px-2 py-1 rounded-full bg-rose-50 text-rose-700 border border-rose-200">No cumple</span>`);
      const sumTxt = (st.sum === null) ? "" : `<span class="text-sm font-semibold">${st.text}</span>`;
      return `
        <div class="border rounded-2xl p-4 bg-slate-50">
          <div class="flex items-center justify-between gap-2">
            <div class="font-semibold">Pareja ${i+1} (‚â• ${th} a√±os)</div>
            <div class="flex items-center gap-2">${sumTxt}${badge}</div>
          </div>
          <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
            ${renderSelect(i, "L")}
            ${renderSelect(i, "R")}
          </div>
        </div>
      `;
    }).join("");

    // Bind select change events
    VET_THRESHOLDS.forEach((th, i) => {
      ["L","R"].forEach(which => {
        const sel = document.getElementById(`vMan_${i}_${which}`);
        if (!sel) return;
        const s = slots[i];
        const current = which==="L" ? s.L : s.R;
        sel.value = current || "";
        sel.onchange = () => {
          const val = sel.value || null;
          if (which==="L") s.L = val; else s.R = val;
          db.veteranasManual.slots = slots;
          db.veteranasManual.msg = "";
          // Si el usuario cambia manualmente, reiniciamos el "noMore" del auto para no mezclar mensajes.
          if (!db.veteranasMeta) db.veteranasMeta = { noMore: false, lastMsg: "" };
          db.veteranasMeta.noMore = false;
          db.veteranasMeta.lastMsg = "";
          save();
        };
      });
    });

    msg.textContent = db.veteranasManual?.msg || "";
    return;
  }

  // --- AUTO MODE (existing behaviour) ---
  const pairs = Array.isArray(db.veteranasPairs) ? db.veteranasPairs : [];

  if (!pairs.length) {
    if (db.veteranasMeta && db.veteranasMeta.noMore) {
      msg.innerHTML = `<b>No es posible generar m√°s parejas nuevas</b> con la selecci√≥n actual.<br/>${escapeHtml(db.veteranasMeta.lastMsg || "")}`;
      return;
    }
    msg.innerHTML = `No se pudo generar una combinaci√≥n v√°lida con las jugadoras actuales. Prueba a:
      <ul class="list-disc ml-5 mt-2">
        <li>A√±adir m√°s jugadoras con edad</li>
        <li>Revisar posiciones (Izquierda/Derecha/Comod√≠n)</li>
        <li>Pulsar ‚ÄúRecalcular parejas‚Äù</li>
      </ul>`;
    return;
  }

  msg.textContent = "";
  wrap.innerHTML = pairs.map((p, i) => {
    const a = p.a, b = p.b;
    const sum = p.sum;
    const okBadge = sum >= p.threshold
      ? '<span class="text-xs px-2 py-1 rounded-full bg-emerald-50 text-emerald-700 border border-emerald-200">OK</span>'
      : '<span class="text-xs px-2 py-1 rounded-full bg-rose-50 text-rose-700 border border-rose-200">No cumple</span>';
    return `
      <div class="border rounded-2xl p-4 bg-slate-50">
        <div class="flex flex-wrap items-center justify-between gap-2">
          <div class="font-semibold">Pareja ${i + 1} (‚â• ${p.threshold} a√±os)</div>
          <div class="flex items-center gap-2">
            <span class="text-sm font-semibold">${sum} a√±os</span>
            ${okBadge}
          </div>
        </div>
        <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
          <div class="bg-white border rounded-xl p-3">
            <div class="font-medium">${escapeHtml(a.name)}</div>
            <div class="text-xs text-slate-600">${sideLabel(a.side)} ¬∑ ${a.age} a√±os</div>
          </div>
          <div class="bg-white border rounded-xl p-3">
            <div class="font-medium">${escapeHtml(b.name)}</div>
            <div class="text-xs text-slate-600">${sideLabel(b.side)} ¬∑ ${b.age} a√±os</div>
          </div>
        </div>
      </div>
    `;
  }).join("");

}

// Eventos UI Veteranas
document.getElementById("btnAddVets")?.addEventListener("click", addVetsPlayer);
document.getElementById("btnRecalcVets")?.addEventListener("click", () => {
  recalcVeteranas();
  // Al recalcular, cambia a pesta√±a veteranas por si el usuario estaba ya ah√≠ (sin saltos)
  setTab("veteranas");
});
document.getElementById("btnClearVets")?.addEventListener("click", clearVetsPlayers);

// Enter para a√±adir
document.getElementById("vName")?.addEventListener("keydown", (e) => {
  if (e.key === "Enter") addVetsPlayer();
});
document.getElementById("vAge")?.addEventListener("keydown", (e) => {
  if (e.key === "Enter") addVetsPlayer();
});

</script>
</body>
</html>
